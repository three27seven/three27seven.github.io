<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>stm32-flash的读写</title>
    <link href="/2024/10/21/stm32-flash%E7%9A%84%E8%AF%BB%E5%86%99/"/>
    <url>/2024/10/21/stm32-flash%E7%9A%84%E8%AF%BB%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><blockquote><p>本实验本来是关于flash模拟eeprom</p><p>但由于笔者问题，所以本文暂时只写了关于flash部分，而关于模拟eeprom暂时还没有</p></blockquote><p>学习博客为：</p><ul><li><p>首先，我们需要知道flash是什么</p><p>flash存储着操控stm32的程序，所以它是一个存储区域</p></li><li><p>其次，EEPROM是什么？</p><p>EEPROM也是一块存储区域</p></li><li><p>那么，为什么要让flash模拟EEPROM？</p><p>因为它们存储的方式不同，导致EEPROM优越于flash，而由于EEPROM的价格高于flash，所以通常单片机采用flash，但又由于实际工程项目中需要EEPROM，所以我们探索出一种让flash模拟EEPROM的方法</p></li></ul><p>其中官方文档给出了其二者的差异性和区别，需要官方文档可直接搜AN2594</p><blockquote><p>On the other hand, the microcontrollers used in those systems are each time more often  based on embedded Flash memory. To eliminate components, save silicon space and  reduce system cost, the STM32F10xxx Flash memory may be used instead of EEPROM for  simultaneous code and data storage.</p><p>Unlike Flash memory, however, external EEPROM does not require an erase operation to  free up space before data can be rewritten. Hence a special software management is  required to store data into embedded Flash memory</p></blockquote><p>翻译</p><blockquote><p>另一方面，这些系统中使用的微控制器每次都更多地基于嵌入式闪存。为了省去元件、节省芯片空间和降低系统成本，可以使用 STM32F10xxx 闪存代替 EEPROM 来同步存储代码和数据</p><p>然而，与 Flash 存储器不同的是，外部 EEPROM 不需要在重写数据之前进行擦除操作来释放空间。因此，需要特殊的软件管理才能将数据存储到嵌入式闪存中。</p></blockquote><p><strong>我的理解如下</strong></p><p>如果将写数据比作吃饭，flash相当于你吃午饭前必须把早饭吐出来，而EEPROM不需要你吐掉早饭你只需要正常吃饭就行了。</p><p>理解为什么要将flash模拟EEPROM后，我们可以正式学习相关内容了</p><p><strong>本文学习知识点如下</strong></p><ul><li><strong>如何读、写flash</strong></li><li><strong>如何将flash模拟EEPROM</strong></li></ul><h2 id="flash"><a href="#flash" class="headerlink" title="flash"></a>flash</h2><p>学习博客为：</p><p><a href="https://blog.csdn.net/will_95/article/details/117079451">HAL读写FLASH笔记_hal flash 读写-CSDN博客</a></p><p><a href="https://blog.csdn.net/LeeSincere521/article/details/107779652">HAL库 FLASH程序编写注意事项_hal库的flash写函数的注意事项-CSDN博客</a></p><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><p>写有以下四个步骤</p><ul><li>解锁</li><li>擦除</li><li>写</li><li>上锁</li></ul><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>HAL有集成函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_FLASH_Unlock(); <br></code></pre></td></tr></table></figure><h4 id="擦除"><a href="#擦除" class="headerlink" title="擦除"></a>擦除</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_FLASHEx_Erase</span><span class="hljs-params">(FLASH_EraseInitTypeDef *pEraseInit, <span class="hljs-type">uint32_t</span> *PageError)</span><br></code></pre></td></tr></table></figure><ul><li>*<em>FLASH_EraseInitTypeDef <em>pEraseInit</em></em></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">uint32_t</span> TypeErase;   <br>  <br>  <span class="hljs-type">uint32_t</span> Banks;         <br>  <br>  <span class="hljs-type">uint32_t</span> PageAddress; <br>    <br>  <span class="hljs-type">uint32_t</span> NbPages;     <br>                                                          <br>&#125; FLASH_EraseInitTypeDef;<br></code></pre></td></tr></table></figure><ul><li>TypeErase擦除方式</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLASH_TYPEERASE_PAGES     0x00U  <span class="hljs-comment">/*!&lt;Pages erase only页擦除*/</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLASH_TYPEERASE_MASSERASE 0x02U  <span class="hljs-comment">/*!&lt;Flash mass erase activation块擦除*/</span></span><br></code></pre></td></tr></table></figure><ul><li><p>NbPages,指擦除多少页；</p></li><li><p><strong>PageError</strong></p></li></ul><p>HAL库里给出解释了</p><blockquote><ul><li>@param[out]  PageError pointer to variable  that</li><li>contains the configuration information on faulty page in case of error</li><li>(0xFFFFFFFF means that all the pages have been correctly erased)</li></ul></blockquote><p>总而言之，其为发生错误的扇区地址 </p><h4 id="写-1"><a href="#写-1" class="headerlink" title="写"></a>写</h4><p>HAL库中有集成函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_FLASH_Program(<span class="hljs-type">uint32_t</span> TypeProgram, <span class="hljs-type">uint32_t</span> Address, <span class="hljs-type">uint64_t</span> Data)<br></code></pre></td></tr></table></figure><ul><li>其中TypeProgram是指写入方式</li></ul><blockquote><p>FLASH_TYPEPROGRAM_DOUBLEWORD 单次8个字节的方式<br>FLASH_TYPEPROGRAM_FAST 单次32行8个字节的方式<br>FLASH_TYPEPROGRAM_FAST_AND_LAST 单次32行8个字节的方式，但是是烧写地址的最后一页。</p></blockquote><ul><li>Address不用多说，写入的地址</li><li>data</li></ul><h4 id="上锁"><a href="#上锁" class="headerlink" title="上锁"></a>上锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_FLASH_Lock();<br></code></pre></td></tr></table></figure><h4 id="写函数（总）"><a href="#写函数（总）" class="headerlink" title="写函数（总）"></a>写函数（总）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br>FLASH_EraseInitTypeDef erasestruct;<br><span class="hljs-type">uint32_t</span> erases_error = <span class="hljs-number">0x00</span>;<span class="hljs-comment">//定义一个数据类型，借该数据类型的地址来写error</span><br><br>erasestruct.NbPages = length/<span class="hljs-number">2048</span>+<span class="hljs-number">1</span>;<br>erasestruct.PageAddress = addr;<br>erasestruct.TypeErase = FLASH_TYPEERASE_PAGES;<br><br><span class="hljs-keyword">if</span>(HAL_FLASHEx_Erase(&amp;erasestruct,&amp;erases_error) != HAL_OK)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">flash_write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr,<span class="hljs-type">uint8_t</span> *data,<span class="hljs-type">uint32_t</span> length)</span><br>&#123;<br><br><span class="hljs-type">uint16_t</span> i = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-comment">//解锁</span><br>HAL_FLASH_Unlock(); <br><br><span class="hljs-comment">//判断需写区域是否空白，如果空白，则擦除，反之则不需要擦除</span><br><span class="hljs-keyword">if</span>(*((<span class="hljs-type">uint32_t</span> *)addr) == <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">else</span> flash_earse(addr,length);<br><br><br><span class="hljs-comment">//写</span><br><span class="hljs-comment">////输入单片机的为32位数据，因此将8位数据整合为32位</span><br><span class="hljs-type">uint32_t</span> _data[length/<span class="hljs-number">4</span>];<br><span class="hljs-built_in">memcpy</span>(_data,data,length);<br><span class="hljs-keyword">while</span>(i&lt;(length/<span class="hljs-number">4</span>))<br>&#123;<br><span class="hljs-keyword">if</span>(HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,addr,_data[i]) == HAL_OK)<br>&#123;<br>addr = +<span class="hljs-number">4</span>;<br>i = +<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">else</span> <br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">//上锁</span><br>HAL_FLASH_Lock();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><p>读函数有些问题，笔者还没解决</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>发送一段数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">/* USER CODE BEGIN 1 */</span><br><br>  <span class="hljs-comment">/* USER CODE END 1 */</span><br><br>  <span class="hljs-comment">/* MCU Configuration--------------------------------------------------------*/</span><br><br>  <span class="hljs-comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span><br>  HAL_Init();<br><br>  <span class="hljs-comment">/* USER CODE BEGIN Init */</span><br><br>  <span class="hljs-comment">/* USER CODE END Init */</span><br><br>  <span class="hljs-comment">/* Configure the system clock */</span><br>  SystemClock_Config();<br><br>  <span class="hljs-comment">/* USER CODE BEGIN SysInit */</span><br><br>  <span class="hljs-comment">/* USER CODE END SysInit */</span><br><br>  <span class="hljs-comment">/* Initialize all configured peripherals */</span><br>  MX_GPIO_Init();<br>  MX_USART1_UART_Init();<br>  MX_TIM2_Init();<br>  MX_RTC_Init();<br>  MX_SDIO_SD_Init();<br>  MX_FSMC_Init();<br>  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br><br><span class="hljs-comment">//</span><br><span class="hljs-type">uint8_t</span> b[<span class="hljs-number">64</span>] = <span class="hljs-string">&quot;aaaa&quot;</span>;<br><span class="hljs-comment">//</span><br>  <span class="hljs-comment">/* USER CODE END 2 */</span><br><br>  <span class="hljs-comment">/* Infinite loop */</span><br>  <span class="hljs-comment">/* USER CODE BEGIN WHILE */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-comment">/* USER CODE END WHILE */</span><br><br>    <span class="hljs-comment">/* USER CODE BEGIN 3 */</span><br><br><br>flash_write(test_addr,(<span class="hljs-type">uint8_t</span> *)b,<span class="hljs-keyword">sizeof</span>(b));<br>flash_read((<span class="hljs-type">uint8_t</span> *)save_addr,test_addr,<span class="hljs-keyword">sizeof</span>(b));<br><span class="hljs-comment">//printf(&quot;sdfdfoujgdf\r\n&quot;);</span><br><span class="hljs-comment">//printf(&quot;save_addr_data = %c&quot;,*save_addr);</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\r\n&quot;</span>);<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><br>  &#125;<br>  <span class="hljs-comment">/* USER CODE END 3 */</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MCU</category>
      
      <category>STM32</category>
      
      <category>base</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>STM32入门：ov7725与LCD连接</title>
    <link href="/2024/09/29/STM32%E5%85%A5%E9%97%A8%EF%BC%9Aov7725%E4%B8%8ELCD%E8%BF%9E%E6%8E%A5/"/>
    <url>/2024/09/29/STM32%E5%85%A5%E9%97%A8%EF%BC%9Aov7725%E4%B8%8ELCD%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<ul><li>实验目的：将摄像头所示图像显示到LCD屏幕上去。</li></ul><p>摄像头拍到的图像,是由一个个色块组成的，而这些色块代表着信息（它们的位置和颜色）</p><ul><li>而将摄像头所示图像显示到LCD屏幕需要以下两步:</li></ul><ol><li>从摄像头读取出色块信息</li><li>将色块信息转移到LCD屏幕上</li></ol><ul><li>首先我们需要知道色块信息储存在哪里？</li></ul><p>正点原子的OV7725自带一个FIFO芯片，储存着色块信息</p><ul><li>综上，摄像头与LCD的连接步骤如下：</li></ul><p><strong>摄像头捕捉图像——产生色块信息——将色块信息储存在FIFO中——LCD再读取</strong></p><p>我们将逐步讲解</p><p>ps.本实验用具，正点原子STM32F103ZET6精英开发板，ov7725模块</p><p>资料下载如下<a href="https://pan.baidu.com/s/1K07LjkJEmlxcnv_r215tXg?_at_=1727252850614#list/path=%2Fsharelink1102113311042-282735585891847%2F%E3%80%90%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E3%80%91OV7725%E6%A8%A1%E5%9D%97%E3%80%90%E5%B8%A6FIFO%E3%80%91%2F%E3%80%90%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E3%80%91ATK-OV7725%E6%91%84%E5%83%8F%E5%A4%B4%E6%A8%A1%E5%9D%97%E8%B5%84%E6%96%99%2F%E3%80%90%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E3%80%91ATK-OV7725%E6%91%84%E5%83%8F%E5%A4%B4%E6%A8%A1%E5%9D%97%E8%B5%84%E6%96%99%EF%BC%88%E6%96%B0%E8%B5%84%E6%96%99%EF%BC%89&parentPath=%2Fsharelink1102113311042-282735585891847%3Flogin_type">【正点原子】OV7725模块【带FIFO】_免费高速下载|百度网盘-分享无限制 (baidu.com)</a></p><h2 id="一、摄像头捕捉图像"><a href="#一、摄像头捕捉图像" class="headerlink" title="一、摄像头捕捉图像"></a>一、摄像头捕捉图像</h2><p>摄像头能捕捉头像的前提是，摄像头启动</p><h3 id="1、摄像头启动"><a href="#1、摄像头启动" class="headerlink" title="1、摄像头启动"></a>1、摄像头启动</h3><p>摄像头启动分为三个方面</p><ul><li>硬件启动（通过GPIO口）</li><li>通讯方式启动(通讯方式名为SCCB)（通讯方式可以类比于写字用的笔，通讯方式的不同则写字用的笔也不同）</li><li>软件启动(我们也称软件复位)</li></ul><h4 id="（1）硬件启动"><a href="#（1）硬件启动" class="headerlink" title="（1）硬件启动"></a>（1）硬件启动</h4><p>即GPIO口启动，我们来看看OV7725有哪些GPIO口</p><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925184419568.png" alt="image-20240925184419568"></p><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925170130695.png" alt="image-20240925170130695"></p><p>通过cube_mx将这些初始化就行了</p><p>值得注意的是，基本都是上拉</p><h4 id="（2）通讯方式启动"><a href="#（2）通讯方式启动" class="headerlink" title="（2）通讯方式启动"></a>（2）通讯方式启动</h4><p>该摄像头使用的是SCCB通讯方式</p><p>关于SCCB的理论，有篇博客讲了，博客地址如下<a href="https://www.cnblogs.com/aslmer/p/5965229.html">OV7725学习之SCCB协议（一） - aslmer - 博客园 (cnblogs.com)</a></p><p>而我们这里讲述如何将理论转为代码，建议一边对着时序图一边看代码，基础时序图知识如下<a href="https://blog.csdn.net/tilblackout/article/details/131447687#:~:text=%E6%96%87%E7%AB%A0%E4%BB%8B%E7%BB%8D%E4%BA%86%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%9A%84%E5%9F%BA">时序图基础知识_运算器时序图-CSDN博客</a></p><p>通讯方式启动方式如下</p><ul><li>开始信号</li><li>发送数据</li><li>结束信号</li></ul><h5 id="①init"><a href="#①init" class="headerlink" title="①init"></a>①init</h5><p>SCCB也有GPIO需要初始化，就是SCL,SDA</p><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925194904081.png" alt="image-20240925194904081"></p><h5 id="①开始信号结束信号"><a href="#①开始信号结束信号" class="headerlink" title="①开始信号结束信号"></a>①开始信号结束信号</h5><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925191845068.png" alt="image-20240925191845068"></p><p>其中开始与结束的分割如下</p><p>STA:start</p><p>STO:stop</p><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925191839771.png" alt="image-20240925191839771"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sccb_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ATK_MC7725F_SCCB_SDA(<span class="hljs-number">1</span>);<br>    ATK_MC7725F_SCCB_SCL(<span class="hljs-number">1</span>);<br>    atk_mc7725f_sccb_delay();<br>    ATK_MC7725F_SCCB_SDA(<span class="hljs-number">0</span>);<br>    atk_mc7725f_sccb_delay();<br>    ATK_MC7725F_SCCB_SCL(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief       SCCB接口停止信号</span><br><span class="hljs-comment"> * @param       无</span><br><span class="hljs-comment"> * @retval      无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sccb_stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ATK_MC7725F_SCCB_SDA(<span class="hljs-number">0</span>);<br>    atk_mc7725f_sccb_delay();<br>    ATK_MC7725F_SCCB_SCL(<span class="hljs-number">1</span>);<br>    atk_mc7725f_sccb_delay();<br>    ATK_MC7725F_SCCB_SDA(<span class="hljs-number">1</span>);<br>    atk_mc7725f_sccb_delay();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③发送字节"><a href="#③发送字节" class="headerlink" title="③发送字节"></a>③发送字节</h5><p>数据转化为01二进制由SDA发出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sccb_write_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> dat)</span><br>&#123;<br>    <span class="hljs-type">int8_t</span> dat_index;<br>    <span class="hljs-type">uint8_t</span> dat_bit;<br>    <br>    <span class="hljs-keyword">for</span> (dat_index=<span class="hljs-number">7</span>; dat_index&gt;=<span class="hljs-number">0</span>; dat_index--)<br>    &#123;<br>        dat_bit = (dat &gt;&gt; dat_index) &amp; <span class="hljs-number">0x01</span>;<br>        ATK_MC7725F_SCCB_SDA(dat_bit);<br>        atk_mc7725f_sccb_delay();<br>        ATK_MC7725F_SCCB_SCL(<span class="hljs-number">1</span>);<br>        atk_mc7725f_sccb_delay();<br>        ATK_MC7725F_SCCB_SCL(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    ATK_MC7725F_SCCB_SDA(<span class="hljs-number">1</span>);<br>    atk_mc7725f_sccb_delay();<br>    ATK_MC7725F_SCCB_SCL(<span class="hljs-number">1</span>);<br>    atk_mc7725f_sccb_delay();<br>    ATK_MC7725F_SCCB_SCL(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>数据转换重要的是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dat_bit = (dat &gt;&gt; dat_index) &amp; <span class="hljs-number">0x01</span>;<br></code></pre></td></tr></table></figure><p>可以自行用数据试一下为什么如此</p><h5 id="④接收字节"><a href="#④接收字节" class="headerlink" title="④接收字节"></a>④接收字节</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (dat_index=<span class="hljs-number">7</span>; dat_index&gt;=<span class="hljs-number">0</span>; dat_index--)<br> &#123;<br>     atk_mc7725f_sccb_delay();<br>     ATK_MC7725F_SCCB_SCL(<span class="hljs-number">1</span>);<br>     dat_bit = ATK_MC7725F_SCCB_READ_SDA();<br>     *dat |= (dat_bit &lt;&lt; dat_index);<br>     atk_mc7725f_sccb_delay();<br>     ATK_MC7725F_SCCB_SCL(<span class="hljs-number">0</span>);<br> &#125;<br> <br> atk_mc7725f_sccb_delay();<br> ATK_MC7725F_SCCB_SCL(<span class="hljs-number">1</span>);<br> atk_mc7725f_sccb_delay();<br> ATK_MC7725F_SCCB_SCL(<span class="hljs-number">0</span>);<br> atk_mc7725f_sccb_delay();<br> ATK_MC7725F_SCCB_SDA(<span class="hljs-number">0</span>);<br> atk_mc7725f_sccb_delay();<br></code></pre></td></tr></table></figure><h5 id="⑤发送数据"><a href="#⑤发送数据" class="headerlink" title="⑤发送数据"></a>⑤发送数据</h5><p>字节构成数据，而数据又按照一定的方式发出</p><p>这边建议再看一遍理论博客，对此进行对照，<a href="https://www.cnblogs.com/aslmer/p/5965229.html">OV7725学习之SCCB协议（一） - aslmer - 博客园 (cnblogs.com)</a>或者看时序图</p><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925194649651.png" alt="image-20240925194649651"></p><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925194702715.png" alt="image-20240925194702715"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief       SCCB接口3阶段写传输</span><br><span class="hljs-comment"> * @param       id_addr : ID Address</span><br><span class="hljs-comment"> *              sub_addr: Sub-address</span><br><span class="hljs-comment"> *              dat     : Write Data</span><br><span class="hljs-comment"> * @retval      无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sccb_3_phase_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> id_addr, <span class="hljs-type">uint8_t</span> sub_addr, <span class="hljs-type">uint8_t</span> dat)</span><br>&#123;<br>    atk_mc7725f_sccb_start();<br>    atk_mc7725f_sccb_write_byte((id_addr &lt;&lt; <span class="hljs-number">1</span>) | ATK_MC7725F_SCCB_WRITE);<br>    atk_mc7725f_sccb_write_byte(sub_addr);<br>    atk_mc7725f_sccb_write_byte(dat);<br>    atk_mc7725f_sccb_stop();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief       SCCB接口2阶段写传输</span><br><span class="hljs-comment"> * @param       id_addr : ID Address</span><br><span class="hljs-comment"> *              sub_addr: Sub-address</span><br><span class="hljs-comment"> * @retval      无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sccb_2_phase_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> id_addr, <span class="hljs-type">uint8_t</span> sub_addr)</span><br>&#123;<br>    atk_mc7725f_sccb_start();<br>    atk_mc7725f_sccb_write_byte((id_addr &lt;&lt; <span class="hljs-number">1</span>) | ATK_MC7725F_SCCB_WRITE);<br>    atk_mc7725f_sccb_write_byte(sub_addr);<br>    atk_mc7725f_sccb_stop();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief       SCCB接口2阶段读传输</span><br><span class="hljs-comment"> * @param       id_addr: ID Address</span><br><span class="hljs-comment"> *              dat: 读取到的数据</span><br><span class="hljs-comment"> * @retval      无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sccb_2_phase_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> id_addr, <span class="hljs-type">uint8_t</span> *dat)</span><br>&#123;<br>    atk_mc7725f_sccb_start();<br>    atk_mc7725f_sccb_write_byte((id_addr &lt;&lt; <span class="hljs-number">1</span>) | ATK_MC7725F_SCCB_READ);<br>    atk_mc7725f_sccb_read_byte(dat);<br>    atk_mc7725f_sccb_stop();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）软件启动-软件复位"><a href="#（3）软件启动-软件复位" class="headerlink" title="（3）软件启动(软件复位)"></a>（3）软件启动(软件复位)</h4><p>复位，就是将曾经写入外设的乱七八糟的所有东西清除，变得干干净净，</p><p>我们将复位比作按钮，按下这个按钮就复位成功</p><p>按钮是地址，按下这个动作是向地址写入相应的命令（该图来源资料——参考资料——datasheet）</p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925195333115.png" alt="image-20240925195333115" style="zoom:67%;"><p>如上地址是0x12，我们将它命名为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ATK_MC7725F_REG_COM7        0x12</span><br></code></pre></td></tr></table></figure><p>我们对它写入的命令，二进制为1000 0000转为十六进制则是0x80</p><p>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sw_reset</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    atk_mc7725f_write_reg(ATK_MC7725F_REG_COM7, <span class="hljs-number">0x80</span>);<br>    delay_ms(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>而write_reg是SCCB通讯里发送数据的集合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//SCCB写入方式，三个阶段，主机向从机（摄像头）写入摄像头ID（地址），需要写的摄像头的寄存器的地址，写入的数据</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_write_reg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg, <span class="hljs-type">uint8_t</span> dat)</span><br>&#123;<br>    atk_mc7725f_sccb_3_phase_write(ATK_MC7725F_SCCB_ADDR, reg, dat);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、产生色块信息"><a href="#二、产生色块信息" class="headerlink" title="二、产生色块信息"></a>二、产生色块信息</h2><p>首先我们需要知道色块信息有哪些</p><h3 id="（1）色块信息"><a href="#（1）色块信息" class="headerlink" title="（1）色块信息"></a>（1）色块信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_set_light_mode</span><span class="hljs-params">(<span class="hljs-type">atk_mc7725f_light_mode_t</span> mode)</span>;                                  <span class="hljs-comment">/* 设置ATK-MC7725F模块灯光模式 */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_set_color_saturation</span><span class="hljs-params">(<span class="hljs-type">atk_mc7725f_color_saturation_t</span> saturation)</span>;                <span class="hljs-comment">/* 设置ATK-MC7725F模块色彩饱和度 */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_set_brightness</span><span class="hljs-params">(<span class="hljs-type">atk_mc7725f_brightness_t</span> brightness)</span>;                            <span class="hljs-comment">/* 设置ATK-MC7725F模块亮度 */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_set_contrast</span><span class="hljs-params">(<span class="hljs-type">atk_mc7725f_contrast_t</span> contrast)</span>;                                  <span class="hljs-comment">/* 设置ATK-MC7725F模块对比度 */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_set_special_effect</span><span class="hljs-params">(<span class="hljs-type">atk_mc7725f_special_effect_t</span> effect)</span>;                        <span class="hljs-comment">/* 设置ATK-MC7725F模块特殊效果 */</span><br></code></pre></td></tr></table></figure><p>关于这些我所知不多，详细的可以自己去工程文件看，但总的来说就是根据datasheet里的指令地址来写</p><h2 id="三、将色块信息储存在FIFO中"><a href="#三、将色块信息储存在FIFO中" class="headerlink" title="三、将色块信息储存在FIFO中"></a>三、将色块信息储存在FIFO中</h2><h3 id="（1）FIFO"><a href="#（1）FIFO" class="headerlink" title="（1）FIFO"></a>（1）FIFO</h3><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925200927305.png" alt="image-20240925200927305"></p><blockquote><p>⚫ VGA，即分辨率为 640x480 的输出格式</p><p>⚫ QVGA，即分辨率为 320*240 的输出格式</p><p>⚫ QQVGA，即分辨率为 160*120 的输出格式</p></blockquote><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240927185026774.png" alt="image-20240927185026774" style="zoom:50%;"><h4 id="①将数据写在FIFO"><a href="#①将数据写在FIFO" class="headerlink" title="①将数据写在FIFO"></a>①将数据写在FIFO</h4><p>采用的中断函数</p><h2 id="四、LCD读取"><a href="#四、LCD读取" class="headerlink" title="四、LCD读取"></a>四、LCD读取</h2><p>LCD读取分为两步</p><ul><li>从FIFO中得到数据</li><li>将得到的数据写入LCD中</li></ul><h3 id="（1）从FIFO中得到数据"><a href="#（1）从FIFO中得到数据" class="headerlink" title="（1）从FIFO中得到数据"></a>（1）从FIFO中得到数据</h3><p>即读FIFO</p><p>读FIFO的时序图如下</p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240927190106926.png" alt="image-20240927190106926" style="zoom: 33%;"><p>总结为</p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240927190218364.png" alt="image-20240927190218364" style="zoom:33%;"><p>将其编程实现为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">ATK_MC7725F_RCLK(<span class="hljs-number">0</span>);<br>dat = (atk_mc7725f_get_byte_data() &lt;&lt; <span class="hljs-number">8</span>);<br>ATK_MC7725F_RCLK(<span class="hljs-number">1</span>);<br>ATK_MC7725F_RCLK(<span class="hljs-number">0</span>);<br>dat |= atk_mc7725f_get_byte_data();<br>ATK_MC7725F_RCLK(<span class="hljs-number">1</span>);<br>*dts = dat;<br></code></pre></td></tr></table></figure><p>atk_mc7725f_get_byte_data()的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_get_byte_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> dat = <span class="hljs-number">0</span>;<br>    <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (ATK_MC7725F_DATA_PIN_IN_SAME_GPIO_PORT == 0)</span><br>    dat |= (((ATK_MC7725F_D0_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D0_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">0</span>;<br>    dat |= (((ATK_MC7725F_D1_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D1_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">1</span>;<br>    dat |= (((ATK_MC7725F_D2_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D2_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">2</span>;<br>    dat |= (((ATK_MC7725F_D3_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D3_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">3</span>;<br>    dat |= (((ATK_MC7725F_D4_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D4_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">4</span>;<br>    dat |= (((ATK_MC7725F_D5_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D5_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">5</span>;<br>    dat |= (((ATK_MC7725F_D6_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D6_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">6</span>;<br>    dat |= (((ATK_MC7725F_D7_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D7_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">7</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    dat = ATK_MC7725F_DATE_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_DATA_READ_MASK;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    <span class="hljs-keyword">return</span> dat;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中if (ATK_MC7725F_DATA_PIN_IN_SAME_GPIO_PORT &#x3D;&#x3D; 0)是指读取数据的GPIO口不是一个，比如GPIO口为GPIOA1,GPIOB1,而GPIO口都为一个时，读取数据为dat &#x3D; ATK_MC7725F_DATE_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_DATA_READ_MASK;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> (ATK_MC7725F_DATA_PIN_IN_SAME_GPIO_PORT != 0)</span><br><span class="hljs-comment">/* 连接ATK-MC7725F模块D0~D7的GPIO端口 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ATK_MC7725F_DATE_GPIO_PORT  GPIOC</span><br><span class="hljs-comment">/* 一次性读取连接至ATK-MC7725F的D0~D7的GPIO引脚数据的掩码 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ATK_MC7725F_DATA_READ_MASK  0x00FF</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>掩码的作用：只读GPIOC的低八位，可以用python验证一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">c = <span class="hljs-number">0b1111011100110011</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(c))<br>v = c &amp; <span class="hljs-number">0x00ff</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(v))<br></code></pre></td></tr></table></figure><p>总</p><p>顺便，在读取FIFO数据时，就顺手将数据写入LCD（*dts）了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_get_frame</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> *dts, <span class="hljs-type">atk_mc7725f_get_frame_type_t</span> type)</span><br>&#123;<br>    <span class="hljs-type">uint16_t</span> width_index;<br>    <span class="hljs-type">uint16_t</span> height_index;<br>    <span class="hljs-type">uint16_t</span> dat;<br>    <br>    <span class="hljs-keyword">if</span> (g_atk_mc7725f_sta.frame.handle_flag == FRAME_HANDLE_DONE)<br>    &#123;<br>        <span class="hljs-keyword">return</span> ATK_MC7725F_EEMPTY;<br>    &#125;<br>    <br>    ATK_MC7725F_RRST(<span class="hljs-number">0</span>);<br>    ATK_MC7725F_RCLK(<span class="hljs-number">0</span>);<br>    ATK_MC7725F_RCLK(<span class="hljs-number">1</span>);<br>    ATK_MC7725F_RCLK(<span class="hljs-number">0</span>);<br>    ATK_MC7725F_RRST(<span class="hljs-number">1</span>);<br>    ATK_MC7725F_RCLK(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (height_index=<span class="hljs-number">0</span>; height_index&lt;g_atk_mc7725f_sta.output.height; height_index++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (width_index=<span class="hljs-number">0</span>; width_index&lt;g_atk_mc7725f_sta.output.width; width_index++)<br>        &#123;<br>            ATK_MC7725F_RCLK(<span class="hljs-number">0</span>);<br>            dat = (atk_mc7725f_get_byte_data() &lt;&lt; <span class="hljs-number">8</span>);<br>            ATK_MC7725F_RCLK(<span class="hljs-number">1</span>);<br>            ATK_MC7725F_RCLK(<span class="hljs-number">0</span>);<br>            dat |= atk_mc7725f_get_byte_data();<br>            ATK_MC7725F_RCLK(<span class="hljs-number">1</span>);<br>            *dts = dat;<br>            <span class="hljs-keyword">switch</span> (type)<br>            &#123;<br>                <span class="hljs-keyword">case</span> ATK_MC7725F_GET_FRAME_TYPE_NOINC:<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> ATK_MC7725F_GET_FRAME_TYPE_AUTO_INC:<br>                &#123;<br>                    dts++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">default</span>:<br>                &#123;<br>                    <span class="hljs-keyword">return</span> ATK_MC7725F_EINVAL;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    g_atk_mc7725f_sta.frame.handle_flag = FRAME_HANDLE_DONE;<br>    g_atk_mc7725f_sta.frame.count++;<br>    <br>    <span class="hljs-keyword">return</span> ATK_MC7725F_EOK;<br>&#125;<br></code></pre></td></tr></table></figure><p>将数据写入LCD，&amp;(LCD-&gt;LCD_RAM)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">atk_mc7725f_get_frame(&amp;(LCD-&gt;LCD_RAM), ATK_MC7725F_GET_FRAME_TYPE_NOINC);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MCU</category>
      
      <category>STM32</category>
      
      <category>base</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文明6-科技胜利与统治胜利</title>
    <link href="/2024/05/30/%E6%96%87%E6%98%8E6-%E7%A7%91%E6%8A%80%E8%83%9C%E5%88%A9%E4%B8%8E%E7%BB%9F%E6%B2%BB%E8%83%9C%E5%88%A9/"/>
    <url>/2024/05/30/%E6%96%87%E6%98%8E6-%E7%A7%91%E6%8A%80%E8%83%9C%E5%88%A9%E4%B8%8E%E7%BB%9F%E6%B2%BB%E8%83%9C%E5%88%A9/</url>
    
    <content type="html"><![CDATA[<p>首先，免责声明，入门小白，玩一会写一会，肯定有狭隘的片面之词</p><p>我们都知道，文明有多种胜利方式，其中有科技胜利和统治胜利</p><p>科技胜利是实现飞天</p><p>统治胜利是占领其它文明的原始首都</p><p>而我看来，科技胜利是和统治胜利并行的</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>科技胜利的飞天项目在科技树的最后面，而在点亮飞天的过程中必然会点亮作战单位</p><p>若要先一步点亮飞天，必然先一步点亮作战</p><p>而当你的科技，或者说兵种比其它文明领先的时候，就可以形成碾压式的占领</p><p>比如，当你的敌人还在骑兵作战时，你却先一步点亮了轰炸机，直接是毫无疑问的虐杀</p><p>所以一步先，步步先</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>从三个方面来讲</p><h3 id="开拓者"><a href="#开拓者" class="headerlink" title="开拓者"></a>开拓者</h3><p>最经典的爆铺玩法，即广泛铺城</p><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><p>当你的领土范围足够广时，就代表有足够的地形，足够的资源：</p><p>地形的宽度带来丰富的加成</p><p>资源包括战略资源，加成资源等，其用处多样，战略造兵，加成买卖，奢侈加宜居</p><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>在所拥有的几座城中，选取生产力最高的，猛干开拓者，同时政策中选取增加生产开拓者生产力的，再同时，砍树增加生产力</p><p>当然，由于游戏机制的问题，一座城造的开拓者越多，所需的生产力越多，我的方法是下一座城生产开拓者</p><p>注意：每一座城邦在建立时，初期需要生产弓箭手，当然其它战略单位也可，但是弓箭手最划算，攻击力在初期最高</p><h3 id="科技值"><a href="#科技值" class="headerlink" title="科技值"></a>科技值</h3><p>科技值如何获得，前文以及提过了，再不必多说</p><p>这里重点要说的是，学院最好建在有山多的地方，越多越好，四面环山也不怕，这样增加的科技值是最多的，哪怕一座城只建学院也够回本</p><h3 id="生产力"><a href="#生产力" class="headerlink" title="生产力"></a>生产力</h3><p>生产力的作用不必多说，越多越好，越能领先其它文明</p><p>提升方法如下</p><h4 id="砍树"><a href="#砍树" class="headerlink" title="砍树"></a>砍树</h4><p>丘陵砍树建矿场，平原砍树建三角田</p><p>不要害怕，直接砍，你砍的越多发展越快，建矿山五十回合甚至更多的收益，才能和砍树相比，有这时间，敌人都能达到你家首都了</p><h4 id="工业区"><a href="#工业区" class="headerlink" title="工业区"></a>工业区</h4><p>工业区能给周围的矿场增加生产力，所以最理想的方法是，六个单元格围着一个工业区，生产力暴增</p><h4 id="奇观"><a href="#奇观" class="headerlink" title="奇观"></a>奇观</h4><p>奇观能增加的生产力也很客观，但是可遇而不可求</p><p>综上，丘陵砍树，建矿山，中间搞工业区</p><p>综上方法，科技遥遥领先，军队遥遥领先，统治遥遥领先，很难不赢</p><p>顺便，除非有特殊执念，否则不建议占领全部城市（大冤种）（指我），其中城市以及作战单位的消耗是难以估计的，我最初两千多金币的小金库，到最后差点赤字</p><p>建议除了原始首都，打其它城市，之后然后接受和解，漫天要价，过了一段时间，再打别的城市，然后接受和解，漫天要价，这样，别的文明就是你的小金库啦，诶嘿。</p>]]></content>
    
    
    <categories>
      
      <category>game</category>
      
      <category>文明6</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文明6-如何增加科技值</title>
    <link href="/2024/05/28/%E6%96%87%E6%98%8E6-%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E7%A7%91%E6%8A%80%E5%80%BC/"/>
    <url>/2024/05/28/%E6%96%87%E6%98%8E6-%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E7%A7%91%E6%8A%80%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="如何增加科技值"><a href="#如何增加科技值" class="headerlink" title="如何增加科技值"></a>如何增加科技值</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Q:为什么增加科技值？</p><p>A:加快科技树的点亮速度，在与其它文明争霸时，获得领先地位</p><p>ps.当自家文明还用弓箭手的时候，蛮族都用上线列步兵的窒息感，让人很想吐槽到底谁才是蛮族</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="一、单元格"><a href="#一、单元格" class="headerlink" title="一、单元格"></a>一、单元格</h3><p>有些单元格是可以直接获取科技值的，只需将该单元格的市民图标点亮，则可获得相应的科技值</p><p>而在奇观如百慕大三角附近，所获得的科技值灰常多（听说的，还没遇到过百慕大三角）</p><h3 id="二、学院"><a href="#二、学院" class="headerlink" title="二、学院"></a>二、学院</h3><p>并不是建成学院就可以获得科技值，如果其周围没有任何加成的话，科技值收入为0，相当于浪费生产力。</p><p>而加成分为三部分</p><p>1.地形，相应的地形让学院获得加成，从而增加科技值</p><p>2.建筑</p><p>3.市民，当学院升级为图书馆的时候，就可以点亮上面的市民图标，每个市民点亮2点科技值（是点亮在图书馆的市民），后期到大学的时候，可以点亮三个市民</p><p>ps.市民点亮并非越多越好，不然粮食生产以及其它方面会落下。</p><h3 id="三、掠夺"><a href="#三、掠夺" class="headerlink" title="三、掠夺"></a>三、掠夺</h3><p>是你！野蛮6（doge）</p><p>当你掠夺其他文明的学院时，就可以获得他们学院的科技值，这等好事！！！</p><p>挂路灯典中做法：不管周围文明，但要确保自身兵力强盛，等肥羊可宰之时，一举进攻，掠夺开抢，之后潇洒离去，让羊继续养肥</p>]]></content>
    
    
    <categories>
      
      <category>game</category>
      
      <category>文明6</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
