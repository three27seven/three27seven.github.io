<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STM32入门：ov7725与LCD连接</title>
    <link href="/2024/09/29/STM32%E5%85%A5%E9%97%A8%EF%BC%9Aov7725%E4%B8%8ELCD%E8%BF%9E%E6%8E%A5/"/>
    <url>/2024/09/29/STM32%E5%85%A5%E9%97%A8%EF%BC%9Aov7725%E4%B8%8ELCD%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<ul><li>实验目的：将摄像头所示图像显示到LCD屏幕上去。</li></ul><p>摄像头拍到的图像,是由一个个色块组成的，而这些色块代表着信息（它们的位置和颜色）</p><ul><li>而将摄像头所示图像显示到LCD屏幕需要以下两步:</li></ul><ol><li>从摄像头读取出色块信息</li><li>将色块信息转移到LCD屏幕上</li></ol><ul><li>首先我们需要知道色块信息储存在哪里？</li></ul><p>正点原子的OV7725自带一个FIFO芯片，储存着色块信息</p><ul><li>综上，摄像头与LCD的连接步骤如下：</li></ul><p><strong>摄像头捕捉图像——产生色块信息——将色块信息储存在FIFO中——LCD再读取</strong></p><p>我们将逐步讲解</p><p>ps.本实验用具，正点原子STM32F103ZET6精英开发板，ov7725模块</p><p>资料下载如下<a href="https://pan.baidu.com/s/1K07LjkJEmlxcnv_r215tXg?_at_=1727252850614#list/path=%2Fsharelink1102113311042-282735585891847%2F%E3%80%90%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E3%80%91OV7725%E6%A8%A1%E5%9D%97%E3%80%90%E5%B8%A6FIFO%E3%80%91%2F%E3%80%90%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E3%80%91ATK-OV7725%E6%91%84%E5%83%8F%E5%A4%B4%E6%A8%A1%E5%9D%97%E8%B5%84%E6%96%99%2F%E3%80%90%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E3%80%91ATK-OV7725%E6%91%84%E5%83%8F%E5%A4%B4%E6%A8%A1%E5%9D%97%E8%B5%84%E6%96%99%EF%BC%88%E6%96%B0%E8%B5%84%E6%96%99%EF%BC%89&parentPath=%2Fsharelink1102113311042-282735585891847%3Flogin_type">【正点原子】OV7725模块【带FIFO】_免费高速下载|百度网盘-分享无限制 (baidu.com)</a></p><h2 id="一、摄像头捕捉图像"><a href="#一、摄像头捕捉图像" class="headerlink" title="一、摄像头捕捉图像"></a>一、摄像头捕捉图像</h2><p>摄像头能捕捉头像的前提是，摄像头启动</p><h3 id="1、摄像头启动"><a href="#1、摄像头启动" class="headerlink" title="1、摄像头启动"></a>1、摄像头启动</h3><p>摄像头启动分为三个方面</p><ul><li>硬件启动（通过GPIO口）</li><li>通讯方式启动(通讯方式名为SCCB)（通讯方式可以类比于写字用的笔，通讯方式的不同则写字用的笔也不同）</li><li>软件启动(我们也称软件复位)</li></ul><h4 id="（1）硬件启动"><a href="#（1）硬件启动" class="headerlink" title="（1）硬件启动"></a>（1）硬件启动</h4><p>即GPIO口启动，我们来看看OV7725有哪些GPIO口</p><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925184419568.png" alt="image-20240925184419568"></p><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925170130695.png" alt="image-20240925170130695"></p><p>通过cube_mx将这些初始化就行了</p><p>值得注意的是，基本都是上拉</p><h4 id="（2）通讯方式启动"><a href="#（2）通讯方式启动" class="headerlink" title="（2）通讯方式启动"></a>（2）通讯方式启动</h4><p>该摄像头使用的是SCCB通讯方式</p><p>关于SCCB的理论，有篇博客讲了，博客地址如下<a href="https://www.cnblogs.com/aslmer/p/5965229.html">OV7725学习之SCCB协议（一） - aslmer - 博客园 (cnblogs.com)</a></p><p>而我们这里讲述如何将理论转为代码，建议一边对着时序图一边看代码，基础时序图知识如下<a href="https://blog.csdn.net/tilblackout/article/details/131447687#:~:text=%E6%96%87%E7%AB%A0%E4%BB%8B%E7%BB%8D%E4%BA%86%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%9A%84%E5%9F%BA">时序图基础知识_运算器时序图-CSDN博客</a></p><p>通讯方式启动方式如下</p><ul><li>开始信号</li><li>发送数据</li><li>结束信号</li></ul><h5 id="①init"><a href="#①init" class="headerlink" title="①init"></a>①init</h5><p>SCCB也有GPIO需要初始化，就是SCL,SDA</p><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925194904081.png" alt="image-20240925194904081"></p><h5 id="①开始信号结束信号"><a href="#①开始信号结束信号" class="headerlink" title="①开始信号结束信号"></a>①开始信号结束信号</h5><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925191845068.png" alt="image-20240925191845068"></p><p>其中开始与结束的分割如下</p><p>STA:start</p><p>STO:stop</p><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925191839771.png" alt="image-20240925191839771"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sccb_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ATK_MC7725F_SCCB_SDA(<span class="hljs-number">1</span>);<br>    ATK_MC7725F_SCCB_SCL(<span class="hljs-number">1</span>);<br>    atk_mc7725f_sccb_delay();<br>    ATK_MC7725F_SCCB_SDA(<span class="hljs-number">0</span>);<br>    atk_mc7725f_sccb_delay();<br>    ATK_MC7725F_SCCB_SCL(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief       SCCB接口停止信号</span><br><span class="hljs-comment"> * @param       无</span><br><span class="hljs-comment"> * @retval      无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sccb_stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    ATK_MC7725F_SCCB_SDA(<span class="hljs-number">0</span>);<br>    atk_mc7725f_sccb_delay();<br>    ATK_MC7725F_SCCB_SCL(<span class="hljs-number">1</span>);<br>    atk_mc7725f_sccb_delay();<br>    ATK_MC7725F_SCCB_SDA(<span class="hljs-number">1</span>);<br>    atk_mc7725f_sccb_delay();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="③发送字节"><a href="#③发送字节" class="headerlink" title="③发送字节"></a>③发送字节</h5><p>数据转化为01二进制由SDA发出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sccb_write_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> dat)</span><br>&#123;<br>    <span class="hljs-type">int8_t</span> dat_index;<br>    <span class="hljs-type">uint8_t</span> dat_bit;<br>    <br>    <span class="hljs-keyword">for</span> (dat_index=<span class="hljs-number">7</span>; dat_index&gt;=<span class="hljs-number">0</span>; dat_index--)<br>    &#123;<br>        dat_bit = (dat &gt;&gt; dat_index) &amp; <span class="hljs-number">0x01</span>;<br>        ATK_MC7725F_SCCB_SDA(dat_bit);<br>        atk_mc7725f_sccb_delay();<br>        ATK_MC7725F_SCCB_SCL(<span class="hljs-number">1</span>);<br>        atk_mc7725f_sccb_delay();<br>        ATK_MC7725F_SCCB_SCL(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    ATK_MC7725F_SCCB_SDA(<span class="hljs-number">1</span>);<br>    atk_mc7725f_sccb_delay();<br>    ATK_MC7725F_SCCB_SCL(<span class="hljs-number">1</span>);<br>    atk_mc7725f_sccb_delay();<br>    ATK_MC7725F_SCCB_SCL(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>数据转换重要的是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dat_bit = (dat &gt;&gt; dat_index) &amp; <span class="hljs-number">0x01</span>;<br></code></pre></td></tr></table></figure><p>可以自行用数据试一下为什么如此</p><h5 id="④接收字节"><a href="#④接收字节" class="headerlink" title="④接收字节"></a>④接收字节</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (dat_index=<span class="hljs-number">7</span>; dat_index&gt;=<span class="hljs-number">0</span>; dat_index--)<br> &#123;<br>     atk_mc7725f_sccb_delay();<br>     ATK_MC7725F_SCCB_SCL(<span class="hljs-number">1</span>);<br>     dat_bit = ATK_MC7725F_SCCB_READ_SDA();<br>     *dat |= (dat_bit &lt;&lt; dat_index);<br>     atk_mc7725f_sccb_delay();<br>     ATK_MC7725F_SCCB_SCL(<span class="hljs-number">0</span>);<br> &#125;<br> <br> atk_mc7725f_sccb_delay();<br> ATK_MC7725F_SCCB_SCL(<span class="hljs-number">1</span>);<br> atk_mc7725f_sccb_delay();<br> ATK_MC7725F_SCCB_SCL(<span class="hljs-number">0</span>);<br> atk_mc7725f_sccb_delay();<br> ATK_MC7725F_SCCB_SDA(<span class="hljs-number">0</span>);<br> atk_mc7725f_sccb_delay();<br></code></pre></td></tr></table></figure><h5 id="⑤发送数据"><a href="#⑤发送数据" class="headerlink" title="⑤发送数据"></a>⑤发送数据</h5><p>字节构成数据，而数据又按照一定的方式发出</p><p>这边建议再看一遍理论博客，对此进行对照，<a href="https://www.cnblogs.com/aslmer/p/5965229.html">OV7725学习之SCCB协议（一） - aslmer - 博客园 (cnblogs.com)</a>或者看时序图</p><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925194649651.png" alt="image-20240925194649651"></p><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925194702715.png" alt="image-20240925194702715"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief       SCCB接口3阶段写传输</span><br><span class="hljs-comment"> * @param       id_addr : ID Address</span><br><span class="hljs-comment"> *              sub_addr: Sub-address</span><br><span class="hljs-comment"> *              dat     : Write Data</span><br><span class="hljs-comment"> * @retval      无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sccb_3_phase_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> id_addr, <span class="hljs-type">uint8_t</span> sub_addr, <span class="hljs-type">uint8_t</span> dat)</span><br>&#123;<br>    atk_mc7725f_sccb_start();<br>    atk_mc7725f_sccb_write_byte((id_addr &lt;&lt; <span class="hljs-number">1</span>) | ATK_MC7725F_SCCB_WRITE);<br>    atk_mc7725f_sccb_write_byte(sub_addr);<br>    atk_mc7725f_sccb_write_byte(dat);<br>    atk_mc7725f_sccb_stop();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief       SCCB接口2阶段写传输</span><br><span class="hljs-comment"> * @param       id_addr : ID Address</span><br><span class="hljs-comment"> *              sub_addr: Sub-address</span><br><span class="hljs-comment"> * @retval      无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sccb_2_phase_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> id_addr, <span class="hljs-type">uint8_t</span> sub_addr)</span><br>&#123;<br>    atk_mc7725f_sccb_start();<br>    atk_mc7725f_sccb_write_byte((id_addr &lt;&lt; <span class="hljs-number">1</span>) | ATK_MC7725F_SCCB_WRITE);<br>    atk_mc7725f_sccb_write_byte(sub_addr);<br>    atk_mc7725f_sccb_stop();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief       SCCB接口2阶段读传输</span><br><span class="hljs-comment"> * @param       id_addr: ID Address</span><br><span class="hljs-comment"> *              dat: 读取到的数据</span><br><span class="hljs-comment"> * @retval      无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sccb_2_phase_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> id_addr, <span class="hljs-type">uint8_t</span> *dat)</span><br>&#123;<br>    atk_mc7725f_sccb_start();<br>    atk_mc7725f_sccb_write_byte((id_addr &lt;&lt; <span class="hljs-number">1</span>) | ATK_MC7725F_SCCB_READ);<br>    atk_mc7725f_sccb_read_byte(dat);<br>    atk_mc7725f_sccb_stop();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）软件启动-软件复位"><a href="#（3）软件启动-软件复位" class="headerlink" title="（3）软件启动(软件复位)"></a>（3）软件启动(软件复位)</h4><p>复位，就是将曾经写入外设的乱七八糟的所有东西清除，变得干干净净，</p><p>我们将复位比作按钮，按下这个按钮就复位成功</p><p>按钮是地址，按下这个动作是向地址写入相应的命令（该图来源资料——参考资料——datasheet）</p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925195333115.png" alt="image-20240925195333115" style="zoom:67%;"><p>如上地址是0x12，我们将它命名为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ATK_MC7725F_REG_COM7        0x12</span><br></code></pre></td></tr></table></figure><p>我们对它写入的命令，二进制为1000 0000转为十六进制则是0x80</p><p>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_sw_reset</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    atk_mc7725f_write_reg(ATK_MC7725F_REG_COM7, <span class="hljs-number">0x80</span>);<br>    delay_ms(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>而write_reg是SCCB通讯里发送数据的集合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//SCCB写入方式，三个阶段，主机向从机（摄像头）写入摄像头ID（地址），需要写的摄像头的寄存器的地址，写入的数据</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">atk_mc7725f_write_reg</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> reg, <span class="hljs-type">uint8_t</span> dat)</span><br>&#123;<br>    atk_mc7725f_sccb_3_phase_write(ATK_MC7725F_SCCB_ADDR, reg, dat);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、产生色块信息"><a href="#二、产生色块信息" class="headerlink" title="二、产生色块信息"></a>二、产生色块信息</h2><p>首先我们需要知道色块信息有哪些</p><h3 id="（1）色块信息"><a href="#（1）色块信息" class="headerlink" title="（1）色块信息"></a>（1）色块信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_set_light_mode</span><span class="hljs-params">(<span class="hljs-type">atk_mc7725f_light_mode_t</span> mode)</span>;                                  <span class="hljs-comment">/* 设置ATK-MC7725F模块灯光模式 */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_set_color_saturation</span><span class="hljs-params">(<span class="hljs-type">atk_mc7725f_color_saturation_t</span> saturation)</span>;                <span class="hljs-comment">/* 设置ATK-MC7725F模块色彩饱和度 */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_set_brightness</span><span class="hljs-params">(<span class="hljs-type">atk_mc7725f_brightness_t</span> brightness)</span>;                            <span class="hljs-comment">/* 设置ATK-MC7725F模块亮度 */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_set_contrast</span><span class="hljs-params">(<span class="hljs-type">atk_mc7725f_contrast_t</span> contrast)</span>;                                  <span class="hljs-comment">/* 设置ATK-MC7725F模块对比度 */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_set_special_effect</span><span class="hljs-params">(<span class="hljs-type">atk_mc7725f_special_effect_t</span> effect)</span>;                        <span class="hljs-comment">/* 设置ATK-MC7725F模块特殊效果 */</span><br></code></pre></td></tr></table></figure><p>关于这些我所知不多，详细的可以自己去工程文件看，但总的来说就是根据datasheet里的指令地址来写</p><h2 id="三、将色块信息储存在FIFO中"><a href="#三、将色块信息储存在FIFO中" class="headerlink" title="三、将色块信息储存在FIFO中"></a>三、将色块信息储存在FIFO中</h2><h3 id="（1）FIFO"><a href="#（1）FIFO" class="headerlink" title="（1）FIFO"></a>（1）FIFO</h3><p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240925200927305.png" alt="image-20240925200927305"></p><blockquote><p>⚫ VGA，即分辨率为 640x480 的输出格式</p><p>⚫ QVGA，即分辨率为 320*240 的输出格式</p><p>⚫ QQVGA，即分辨率为 160*120 的输出格式</p></blockquote><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240927185026774.png" alt="image-20240927185026774" style="zoom:50%;"><h4 id="①将数据写在FIFO"><a href="#①将数据写在FIFO" class="headerlink" title="①将数据写在FIFO"></a>①将数据写在FIFO</h4><p>采用的中断函数</p><h2 id="四、LCD读取"><a href="#四、LCD读取" class="headerlink" title="四、LCD读取"></a>四、LCD读取</h2><p>LCD读取分为两步</p><ul><li>从FIFO中得到数据</li><li>将得到的数据写入LCD中</li></ul><h3 id="（1）从FIFO中得到数据"><a href="#（1）从FIFO中得到数据" class="headerlink" title="（1）从FIFO中得到数据"></a>（1）从FIFO中得到数据</h3><p>即读FIFO</p><p>读FIFO的时序图如下</p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240927190106926.png" alt="image-20240927190106926" style="zoom: 33%;"><p>总结为</p><img src="/.top//../../../app1/Typora/ov7725.assets/image-20240927190218364.png" alt="image-20240927190218364" style="zoom:33%;"><p>将其编程实现为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">ATK_MC7725F_RCLK(<span class="hljs-number">0</span>);<br>dat = (atk_mc7725f_get_byte_data() &lt;&lt; <span class="hljs-number">8</span>);<br>ATK_MC7725F_RCLK(<span class="hljs-number">1</span>);<br>ATK_MC7725F_RCLK(<span class="hljs-number">0</span>);<br>dat |= atk_mc7725f_get_byte_data();<br>ATK_MC7725F_RCLK(<span class="hljs-number">1</span>);<br>*dts = dat;<br></code></pre></td></tr></table></figure><p>atk_mc7725f_get_byte_data()的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_get_byte_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> dat = <span class="hljs-number">0</span>;<br>    <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (ATK_MC7725F_DATA_PIN_IN_SAME_GPIO_PORT == 0)</span><br>    dat |= (((ATK_MC7725F_D0_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D0_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">0</span>;<br>    dat |= (((ATK_MC7725F_D1_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D1_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">1</span>;<br>    dat |= (((ATK_MC7725F_D2_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D2_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">2</span>;<br>    dat |= (((ATK_MC7725F_D3_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D3_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">3</span>;<br>    dat |= (((ATK_MC7725F_D4_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D4_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">4</span>;<br>    dat |= (((ATK_MC7725F_D5_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D5_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">5</span>;<br>    dat |= (((ATK_MC7725F_D6_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D6_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">6</span>;<br>    dat |= (((ATK_MC7725F_D7_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_D7_GPIO_PIN) == <span class="hljs-number">0</span>) ? (<span class="hljs-number">0</span>) : (<span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">7</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    dat = ATK_MC7725F_DATE_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_DATA_READ_MASK;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    <span class="hljs-keyword">return</span> dat;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中if (ATK_MC7725F_DATA_PIN_IN_SAME_GPIO_PORT &#x3D;&#x3D; 0)是指读取数据的GPIO口不是一个，比如GPIO口为GPIOA1,GPIOB1,而GPIO口都为一个时，读取数据为dat &#x3D; ATK_MC7725F_DATE_GPIO_PORT-&gt;IDR &amp; ATK_MC7725F_DATA_READ_MASK;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> (ATK_MC7725F_DATA_PIN_IN_SAME_GPIO_PORT != 0)</span><br><span class="hljs-comment">/* 连接ATK-MC7725F模块D0~D7的GPIO端口 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ATK_MC7725F_DATE_GPIO_PORT  GPIOC</span><br><span class="hljs-comment">/* 一次性读取连接至ATK-MC7725F的D0~D7的GPIO引脚数据的掩码 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ATK_MC7725F_DATA_READ_MASK  0x00FF</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>掩码的作用：只读GPIOC的低八位，可以用python验证一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">c = <span class="hljs-number">0b1111011100110011</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(c))<br>v = c &amp; <span class="hljs-number">0x00ff</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(v))<br></code></pre></td></tr></table></figure><p>总</p><p>顺便，在读取FIFO数据时，就顺手将数据写入LCD（*dts）了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">atk_mc7725f_get_frame</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint16_t</span> *dts, <span class="hljs-type">atk_mc7725f_get_frame_type_t</span> type)</span><br>&#123;<br>    <span class="hljs-type">uint16_t</span> width_index;<br>    <span class="hljs-type">uint16_t</span> height_index;<br>    <span class="hljs-type">uint16_t</span> dat;<br>    <br>    <span class="hljs-keyword">if</span> (g_atk_mc7725f_sta.frame.handle_flag == FRAME_HANDLE_DONE)<br>    &#123;<br>        <span class="hljs-keyword">return</span> ATK_MC7725F_EEMPTY;<br>    &#125;<br>    <br>    ATK_MC7725F_RRST(<span class="hljs-number">0</span>);<br>    ATK_MC7725F_RCLK(<span class="hljs-number">0</span>);<br>    ATK_MC7725F_RCLK(<span class="hljs-number">1</span>);<br>    ATK_MC7725F_RCLK(<span class="hljs-number">0</span>);<br>    ATK_MC7725F_RRST(<span class="hljs-number">1</span>);<br>    ATK_MC7725F_RCLK(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (height_index=<span class="hljs-number">0</span>; height_index&lt;g_atk_mc7725f_sta.output.height; height_index++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (width_index=<span class="hljs-number">0</span>; width_index&lt;g_atk_mc7725f_sta.output.width; width_index++)<br>        &#123;<br>            ATK_MC7725F_RCLK(<span class="hljs-number">0</span>);<br>            dat = (atk_mc7725f_get_byte_data() &lt;&lt; <span class="hljs-number">8</span>);<br>            ATK_MC7725F_RCLK(<span class="hljs-number">1</span>);<br>            ATK_MC7725F_RCLK(<span class="hljs-number">0</span>);<br>            dat |= atk_mc7725f_get_byte_data();<br>            ATK_MC7725F_RCLK(<span class="hljs-number">1</span>);<br>            *dts = dat;<br>            <span class="hljs-keyword">switch</span> (type)<br>            &#123;<br>                <span class="hljs-keyword">case</span> ATK_MC7725F_GET_FRAME_TYPE_NOINC:<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> ATK_MC7725F_GET_FRAME_TYPE_AUTO_INC:<br>                &#123;<br>                    dts++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">default</span>:<br>                &#123;<br>                    <span class="hljs-keyword">return</span> ATK_MC7725F_EINVAL;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    g_atk_mc7725f_sta.frame.handle_flag = FRAME_HANDLE_DONE;<br>    g_atk_mc7725f_sta.frame.count++;<br>    <br>    <span class="hljs-keyword">return</span> ATK_MC7725F_EOK;<br>&#125;<br></code></pre></td></tr></table></figure><p>将数据写入LCD，&amp;(LCD-&gt;LCD_RAM)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">atk_mc7725f_get_frame(&amp;(LCD-&gt;LCD_RAM), ATK_MC7725F_GET_FRAME_TYPE_NOINC);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MCU</category>
      
      <category>STM32</category>
      
      <category>base</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32入门05-独立看门狗</title>
    <link href="/2024/06/07/stm32%E5%85%A5%E9%97%A805-%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
    <url>/2024/06/07/stm32%E5%85%A5%E9%97%A805-%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97/</url>
    
    <content type="html"><![CDATA[<p>本实验所需实现的功能如下：</p><p><strong>在配置看门狗后，LED0将常亮，如果KEY UP按键按下，就喂狗，只要KEY UP不停的按，看门狗就一直不会产生复位，保持LED0的常亮，一旦超过看门狗定溢出时间（Tout）还没按，那么将会导致程序重启，这将导致LED0熄灭一次。</strong></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>独立看门狗本质上是一个定时器，这个定时器有一个输出端，可以输出复位信号。</p><p>该定时器是一个12位的递减计数器，当计数器的值减到0的时候，就会产生一个复位信号。</p><p><strong>复位</strong>：是指将设备进行初始化</p><p><strong>喂狗</strong>：如果在计数没减到0之前，重置计数器的值的话，那么就不会产生复位信号。</p><p>ps.我理解的是看门狗要咬人（进行复位），但是只要在他饿之前（计数器的值减到0之前），喂它食物（重置计数器），它就不会咬人（不进行复位）。</p><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p><strong>IWDG在HAL库中的驱动代码在stm32f1xx_hal_iwdg.c文件（及其头文件）中。</strong></p><h3 id="h"><a href="#h" class="headerlink" title=".h"></a>.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _IWDG_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IWDG_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/sys/sys.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">iwdg_init</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> prer, <span class="hljs-type">uint16_t</span> rlr)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">iwdg_feed</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>.h文件很简单，就声明两个函数就行</p><p>1.看门狗初始化<strong>iwdg_init</strong></p><p>2.喂狗程序<strong>iwdg_feed</strong></p><h3 id="c"><a href="#c" class="headerlink" title=".c"></a>.c</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><p>HAL库里有初始化函数，直接用就行，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_IWDG_Init</span><span class="hljs-params">(IWDG_HandleTypeDef *hiwdg)</span>; <br></code></pre></td></tr></table></figure><p>其中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span> <br>IWDG_TypeDef                 *Instance;  <span class="hljs-comment">/* IWDG寄存器基地址 */</span> <br>IWDG_InitTypeDef             Init;       <span class="hljs-comment">/* IWDG 初始化参数 */</span> <br>&#125;IWDG_HandleTypeDef; <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span> <br><span class="hljs-type">uint32_t</span> Prescaler;   <span class="hljs-comment">/* 预分频系数 */</span> <br><span class="hljs-type">uint32_t</span> Reload;      <span class="hljs-comment">/* 重装载值 */</span> <br>&#125; IWDG_InitTypeDef; <br></code></pre></td></tr></table></figure><p>通过以上资料，我们就可以根据需要进行配置了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iwdg.h&quot;</span></span><br><br>IWDG_HandleTypeDef g_iwdg_handle;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">iwdg_init</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> pre,<span class="hljs-type">uint16_t</span> rlr)</span><br>&#123;<br>g_iwdg_handle.Instance = IWDG;<br>g_iwdg_handle.Init.Prescaler = pre;<br>g_iwdg_handle.Init.Reload = rlr;<br>HAL_IWDG_Init(&amp;g_iwdg_handle)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-喂狗"><a href="#2-喂狗" class="headerlink" title="2.喂狗"></a>2.喂狗</h4><p>HAL库里面有专门对其的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_StatusTypeDef <span class="hljs-title function_">HAL_IWDG_Refresh</span><span class="hljs-params">(IWDG_HandleTypeDef *hiwdg)</span>; <br></code></pre></td></tr></table></figure><p>而其的详细讲解，已经在上面初始化说了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iwdg.h&quot;</span></span><br><br>IWDG_HandleTypeDef g_iwdg_handle;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">iwdg_init</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> pre,<span class="hljs-type">uint16_t</span> rlr)</span><br>&#123;<br>g_iwdg_handle.Instance = IWDG;<br>g_iwdg_handle.Init.Prescaler = pre;<br>g_iwdg_handle.Init.Reload = rlr;<br>HAL_IWDG_Init(&amp;g_iwdg_handle)<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">iwdg_feed</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>HAL_IWDG_Refresh(&amp;g_iwdg_handle);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/sys/sys.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/delay/delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/usart/usart.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/BEEP/beep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/LED/led.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/KEY/key.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/WDG/wdg.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><br>HAL_Init();<br>sys_stm32_clock_init(RCC_PLL_MUL9);<br>delay_init(<span class="hljs-number">72</span>);<br>Beep_Init();<br>LED_INIT();<br>KEY_Init();<br>iwdg_init(IWDG_PRESCALER_64,<span class="hljs-number">625</span>);<br>usart_init(<span class="hljs-number">115200</span>);<br>    LED0(<span class="hljs-number">0</span>); <br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (key_scan(<span class="hljs-number">1</span>) == WKUP_PRES)       <br>        &#123;<br>            iwdg_feed();                   <br>        &#125;<br><br>        delay_ms(<span class="hljs-number">10</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MCU</category>
      
      <category>STM32</category>
      
      <category>base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>看门狗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32入门04-外部中断</title>
    <link href="/2024/06/04/stm32%E5%85%A5%E9%97%A8-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/"/>
    <url>/2024/06/04/stm32%E5%85%A5%E9%97%A8-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<p>本实验我们所需实验的功能如下:</p><p><strong>通过外部中断的方式实现key实验中的功能</strong></p><blockquote><p>通过开发板上的三个独立按键控制 LED 灯和蜂鸣器： KEY_UP 控制蜂鸣器翻转，KEY1 控制LED1翻转，KEY0控制LED0&#x2F;LED1同时翻转。</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>外部中断：相当于if函数，如果满足条件，则执行if里面的程序</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>优先级：即有多个外部中断时，根据优先级来判断优先执行哪个中断。</p><p>优先级分为两个：</p><ol><li>抢占优先级</li><li>响应优先级</li></ol><p>判断优先级依据如下：</p><ol><li>抢占优先级高的可以打断正在执行的抢占优先级低的</li><li>抢占优先级相同，响应优先级高的先执行，但无法打断响应优先级低的</li><li>抢占优先级和响应优先级都相同的情况下，自然优先级越高的先执行</li><li>自然优先级:中断向量表中的优先级</li><li>数值越小，表示优先级越高</li></ol><h4 id="优先级分组"><a href="#优先级分组" class="headerlink" title="优先级分组"></a>优先级分组</h4><p><strong>AIRCR寄存器</strong>(共有8bit)的高四位进行优先级分组</p><blockquote><p>第0组：所有4位用于指定响应优先级<br>第1组：最高1位用于指定抢占式优先级，最低3位用于指定响应优先级<br>第2组：最高2位用于指定抢占式优先级，最低2位用于指定响应优先级<br>第3组：最高3位用于指定抢占式优先级，最低1位用于指定响应优先级<br>第4组：所有4位用于指定抢占式优先级</p></blockquote><p>这并不是指选中了第1组，就代表中断有1个抢占优先级，而是指有一位来指定抢占优先级</p><p>而同时，<strong>IPR寄存器</strong>用于控制有几位优先级</p><p>即，AIRCR是控制bit位的分组，IPR是控制哪个bit位占1，比喻一下就是，前者是供你选择吃水果披萨还是芝士披萨，后者是让你选择完后直接把披萨吃了</p><p><img src="/.top//image-20240604103350282.png" alt="image-20240604103350282"></p><blockquote><p>假定设置中断优先级分组为 2。</p><p>然后设置中断3的抢占优先级为 2，响应优先级为 1</p><p>中断6的抢占优先级为 3，响应优先级为0</p><p>中断7的抢占优先级为 2，响应优先级为 0</p><p>那么这 3 个中断的优先级顺序为： 中断 7&gt;中断 3&gt;中断 6。</p><p>上面例子中的中断 3 和中断 7 都可以打断中断 6 的中断。而中断 7 和中断 3 却不可以相互打断！</p></blockquote><p>中断7和中断3不能互相打断,原因很明显</p><p><strong>但是明明中断6的抢占优先级大于中断7和3,但却是中断7和中断3能打断中断6,我有点不理解也不尊重,但我找到的一个资料显示如下:</strong></p><p><img src="/.top//image-20240604104301554.png" alt="image-20240604104301554"></p><p><strong>即数值越小,优先级越高,原因可能是这个?</strong></p><p>注:    在一个工程中，一般只设置一次中断优先级分组（<strong>AIRCR寄存器</strong>）</p><h3 id="EXIT"><a href="#EXIT" class="headerlink" title="EXIT"></a>EXIT</h3><h4 id="工作电路图"><a href="#工作电路图" class="headerlink" title="工作电路图"></a>工作电路图</h4><p><img src="/.top//image-20240604112318783.png" alt="image-20240604112318783"></p><h4 id="寄存器设置"><a href="#寄存器设置" class="headerlink" title="寄存器设置"></a>寄存器设置</h4><p><img src="/.top//image-20240604112408282.png" alt="image-20240604112408282"></p><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><h3 id="h"><a href="#h" class="headerlink" title=".h"></a>.h</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><p>之前都写过，就不再赘述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __EXIT_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __EXIT_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_GPIO_PORT   GPIOE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_GPIO_PIN    GPIO_PIN_4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_CLK_ENABLE()  do&#123;__HAL_RCC_GPIOE_CLK_ENABLE();&#125;while(0)</span><br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_GPIO_PORT   GPIOE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_GPIO_PIN    GPIO_PIN_3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_CLK_ENABLE()  do&#123;__HAL_RCC_GPIOE_CLK_ENABLE();&#125;while(0)</span><br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_GPIO_PORT   GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_GPIO_PIN    GPIO_PIN_0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_CLK_ENABLE()  do&#123;__HAL_RCC_GPIOE_CLK_ENABLE();&#125;while(0)</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br><br></code></pre></td></tr></table></figure><h4 id="2-映射"><a href="#2-映射" class="headerlink" title="2.映射"></a>2.映射</h4><p>将IO口和EXIT线一一映射起来，在寄存器里有讲，不再赘述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __EXIT_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __EXIT_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_GPIO_PORT       GPIOE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_GPIO_PIN        GPIO_PIN_4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_CLK_ENABLE()    do&#123;__HAL_RCC_GPIOE_CLK_ENABLE();&#125;while(0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_IRQN            EXTI4_IRQN</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_GPIO_PORT   GPIOE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_GPIO_PIN    GPIO_PIN_3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_CLK_ENABLE()  do&#123;__HAL_RCC_GPIOE_CLK_ENABLE();&#125;while(0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_IRQN          EXTI3_IRQN</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_GPIO_PORT   GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_GPIO_PIN    GPIO_PIN_0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_CLK_ENABLE()  do&#123;__HAL_RCC_GPIOE_CLK_ENABLE();&#125;while(0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_IRQN          EXTI0_IRQN</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br><br></code></pre></td></tr></table></figure><h4 id="3-定义中断函数"><a href="#3-定义中断函数" class="headerlink" title="3.定义中断函数"></a>3.定义中断函数</h4><p>即相关的中断函数</p><p><img src="/.top//image-20240604142044939.png" alt="image-20240604142044939"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __EXIT_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __EXIT_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/sys/sys.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_GPIO_PORT       GPIOE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_GPIO_PIN        GPIO_PIN_4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_CLK_ENABLE()    do&#123;__HAL_RCC_GPIOE_CLK_ENABLE();&#125;while(0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_IRQN            EXTI4_IRQN</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_IRQHandler      EXTI_IRQHandler</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_GPIO_PORT   GPIOE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_GPIO_PIN    GPIO_PIN_3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_CLK_ENABLE()  do&#123;__HAL_RCC_GPIOE_CLK_ENABLE();&#125;while(0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_IRQN          EXTI3_IRQN</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_IRQHandler    EXTI_IRQHandler</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_GPIO_PORT   GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_GPIO_PIN    GPIO_PIN_0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_CLK_ENABLE()  do&#123;__HAL_RCC_GPIOE_CLK_ENABLE();&#125;while(0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_IRQN          EXTI0_IRQN</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_IRQHandler    EXTI_IRQHandler</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br><br></code></pre></td></tr></table></figure><h3 id="c"><a href="#c" class="headerlink" title=".c"></a>.c</h3><h4 id="1-初始化-1"><a href="#1-初始化-1" class="headerlink" title="1.初始化"></a>1.初始化</h4><h5 id="1-GPIO初始化"><a href="#1-GPIO初始化" class="headerlink" title="(1).GPIO初始化"></a>(1).GPIO初始化</h5><p>pin,mode,speed这些，值得一提的是mode并非八大输出输入法中的一个，而是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  GPIO_MODE_IT_RISING          </span><br>(<span class="hljs-number">0x10110000</span>U)  <span class="hljs-comment">/* 外部中断，上升沿触发检测 */</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  GPIO_MODE_IT_FALLING         </span><br>(<span class="hljs-number">0x10210000</span>U)  <span class="hljs-comment">/* 外部中断，下降沿触发检测 */</span> <br><span class="hljs-comment">/* 外部中断，上升和下降双沿触发检测 */</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  GPIO_MODE_IT_RISING_FALLING    </span><br>(<span class="hljs-number">0x10310000</span>U)   <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;exit.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Exti_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>GPIO_InitTypeDef gpio_init_struct;<br><br>KEY0_CLK_ENABLE();                                  <br>KEY1_CLK_ENABLE();                                 <br>WKUP_CLK_ENABLE();<br><br>gpio_init_struct.Pin = KEY0_GPIO_PIN;<br>gpio_init_struct.Pull = GPIO_PULLUP;<br>    gpio_init_struct.Mode = GPIO_MODE_IT_FALLING;<br>    gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;<br>HAL_GPIO_Init(KEY0_GPIO_PORT,&amp;gpio_init_struct);<br><br>gpio_init_struct.Pin = KEY1_GPIO_PIN;<br>HAL_GPIO_Init(KEY1_GPIO_PORT,&amp;gpio_init_struct);<br><br>gpio_init_struct.Pin = WKUP_GPIO_PIN;<br>gpio_init_struct.Pull = GPIO_PULLDOWN;<br>gpio_init_struct.Mode = GPIO_MODE_IT_RISING;<br>HAL_GPIO_Init(WKUP_GPIO_PORT,&amp;gpio_init_struct);<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="2-中断使能"><a href="#2-中断使能" class="headerlink" title="(2).中断使能"></a>(2).中断使能</h5><p>先设置中断优先级，然后进行映射</p><p><strong>注意</strong>：按理而言需要进行优先级分组，即<strong>HAL_NVIC_SetPriorityGrouping 函数</strong> ，但HAL库初始化时已经调用好了，因此无需再次调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;exit.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Exti_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>GPIO_InitTypeDef gpio_init_struct;<br><br>KEY0_CLK_ENABLE();                                  <br>KEY1_CLK_ENABLE();                                 <br>WKUP_CLK_ENABLE();<br><br>gpio_init_struct.Pin = KEY0_GPIO_PIN;<br>gpio_init_struct.Pull = GPIO_PULLUP;<br>  gpio_init_struct.Mode = GPIO_MODE_IT_FALLING;<br>  gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;<br>HAL_GPIO_Init(KEY0_GPIO_PORT,&amp;gpio_init_struct);<br><br>gpio_init_struct.Pin = KEY1_GPIO_PIN;<br>HAL_GPIO_Init(KEY1_GPIO_PORT,&amp;gpio_init_struct);<br><br>gpio_init_struct.Pin = WKUP_GPIO_PIN;<br>gpio_init_struct.Pull = GPIO_PULLDOWN;<br>gpio_init_struct.Mode = GPIO_MODE_IT_RISING;<br>HAL_GPIO_Init(WKUP_GPIO_PORT,&amp;gpio_init_struct);<br><br>HAL_NVIC_SetPriority(KEY0_IRQN, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>); <br>HAL_NVIC_EnableIRQ(KEY0_IRQN);<br><br>HAL_NVIC_SetPriority(KEY1_IRQN, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <br>HAL_NVIC_EnableIRQ(KEY1_IRQN);<br><br>HAL_NVIC_SetPriority(WKUP_IRQN, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <br>HAL_NVIC_EnableIRQ(WKUP_IRQN);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-中断函数"><a href="#2-中断函数" class="headerlink" title="2.中断函数"></a>2.中断函数</h4><h5 id="1-中断函数映射"><a href="#1-中断函数映射" class="headerlink" title="(1)中断函数映射"></a>(1)中断函数映射</h5><p><img src="/.top//image-20240604150623959.png" alt="image-20240604150623959"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">KEY0_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>HAL_GPIO_EXTI_IRQHandler(KEY0_GPIO_PIN);<br>__HAL_GPIO_EXTI_CLEAR_IT(KEY0_GPIO_PIN);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">KEY1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>HAL_GPIO_EXTI_IRQHandler(KEY1_GPIO_PIN);<br>__HAL_GPIO_EXTI_CLEAR_IT(KEY1_GPIO_PIN);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">WKUP_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>HAL_GPIO_EXTI_IRQHandler(WKUP_GPIO_PIN);<br>__HAL_GPIO_EXTI_CLEAR_IT(WKUP_GPIO_PIN);<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="2-中断函数配置"><a href="#2-中断函数配置" class="headerlink" title="(2)中断函数配置"></a>(2)中断函数配置</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> GPIO_Pin)</span><br>&#123;<br>    delay_ms(<span class="hljs-number">20</span>);      <span class="hljs-comment">/* ???? */</span><br>    <span class="hljs-keyword">switch</span>(GPIO_Pin)<br>    &#123;<br>        <span class="hljs-keyword">case</span> KEY0_GPIO_PIN:<br>            <span class="hljs-keyword">if</span> (KEY0 == <span class="hljs-number">0</span>)<br>            &#123;<br>                LED0_TOGGLE();  <span class="hljs-comment">/* LED0 ????? */</span> <br>                LED1_TOGGLE();  <span class="hljs-comment">/* LED1 ????? */</span> <br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> KEY1_GPIO_PIN:<br>            <span class="hljs-keyword">if</span> (KEY1 == <span class="hljs-number">0</span>)<br>            &#123;<br>                LED0_TOGGLE();  <span class="hljs-comment">/* LED0 ????? */</span> <br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> WKUP_GPIO_PIN:<br>            <span class="hljs-keyword">if</span> (WKUP == <span class="hljs-number">1</span>)<br>            &#123;<br>                BEEP_TOGGLE();  <span class="hljs-comment">/* ??????????? */</span> <br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/sys/sys.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/delay/delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/usart/usart.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/BEEP/beep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/LED/led.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/KEY/key.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/EXIT/exit.h&quot;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">uint8_t</span> key;<br><br>HAL_Init();<br>sys_stm32_clock_init(RCC_PLL_MUL9);<br>delay_init(<span class="hljs-number">72</span>);<br>Beep_Init();<br>LED_INIT();<br>KEY_Init();<br>Exti_Init();<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>delay_ms(<span class="hljs-number">1000</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该死的单片机，这是人学的东西吗？！！！</p>]]></content>
    
    
    <categories>
      
      <category>MCU</category>
      
      <category>STM32</category>
      
      <category>base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>外部中断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文明6-科技胜利与统治胜利</title>
    <link href="/2024/05/30/%E6%96%87%E6%98%8E6-%E7%A7%91%E6%8A%80%E8%83%9C%E5%88%A9%E4%B8%8E%E7%BB%9F%E6%B2%BB%E8%83%9C%E5%88%A9/"/>
    <url>/2024/05/30/%E6%96%87%E6%98%8E6-%E7%A7%91%E6%8A%80%E8%83%9C%E5%88%A9%E4%B8%8E%E7%BB%9F%E6%B2%BB%E8%83%9C%E5%88%A9/</url>
    
    <content type="html"><![CDATA[<p>首先，免责声明，入门小白，玩一会写一会，肯定有狭隘的片面之词</p><p>我们都知道，文明有多种胜利方式，其中有科技胜利和统治胜利</p><p>科技胜利是实现飞天</p><p>统治胜利是占领其它文明的原始首都</p><p>而我看来，科技胜利是和统治胜利并行的</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>科技胜利的飞天项目在科技树的最后面，而在点亮飞天的过程中必然会点亮作战单位</p><p>若要先一步点亮飞天，必然先一步点亮作战</p><p>而当你的科技，或者说兵种比其它文明领先的时候，就可以形成碾压式的占领</p><p>比如，当你的敌人还在骑兵作战时，你却先一步点亮了轰炸机，直接是毫无疑问的虐杀</p><p>所以一步先，步步先</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>从三个方面来讲</p><h3 id="开拓者"><a href="#开拓者" class="headerlink" title="开拓者"></a>开拓者</h3><p>最经典的爆铺玩法，即广泛铺城</p><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><p>当你的领土范围足够广时，就代表有足够的地形，足够的资源：</p><p>地形的宽度带来丰富的加成</p><p>资源包括战略资源，加成资源等，其用处多样，战略造兵，加成买卖，奢侈加宜居</p><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>在所拥有的几座城中，选取生产力最高的，猛干开拓者，同时政策中选取增加生产开拓者生产力的，再同时，砍树增加生产力</p><p>当然，由于游戏机制的问题，一座城造的开拓者越多，所需的生产力越多，我的方法是下一座城生产开拓者</p><p>注意：每一座城邦在建立时，初期需要生产弓箭手，当然其它战略单位也可，但是弓箭手最划算，攻击力在初期最高</p><h3 id="科技值"><a href="#科技值" class="headerlink" title="科技值"></a>科技值</h3><p>科技值如何获得，前文以及提过了，再不必多说</p><p>这里重点要说的是，学院最好建在有山多的地方，越多越好，四面环山也不怕，这样增加的科技值是最多的，哪怕一座城只建学院也够回本</p><h3 id="生产力"><a href="#生产力" class="headerlink" title="生产力"></a>生产力</h3><p>生产力的作用不必多说，越多越好，越能领先其它文明</p><p>提升方法如下</p><h4 id="砍树"><a href="#砍树" class="headerlink" title="砍树"></a>砍树</h4><p>丘陵砍树建矿场，平原砍树建三角田</p><p>不要害怕，直接砍，你砍的越多发展越快，建矿山五十回合甚至更多的收益，才能和砍树相比，有这时间，敌人都能达到你家首都了</p><h4 id="工业区"><a href="#工业区" class="headerlink" title="工业区"></a>工业区</h4><p>工业区能给周围的矿场增加生产力，所以最理想的方法是，六个单元格围着一个工业区，生产力暴增</p><h4 id="奇观"><a href="#奇观" class="headerlink" title="奇观"></a>奇观</h4><p>奇观能增加的生产力也很客观，但是可遇而不可求</p><p>综上，丘陵砍树，建矿山，中间搞工业区</p><p>综上方法，科技遥遥领先，军队遥遥领先，统治遥遥领先，很难不赢</p><p>顺便，除非有特殊执念，否则不建议占领全部城市（大冤种）（指我），其中城市以及作战单位的消耗是难以估计的，我最初两千多金币的小金库，到最后差点赤字</p><p>建议除了原始首都，打其它城市，之后然后接受和解，漫天要价，过了一段时间，再打别的城市，然后接受和解，漫天要价，这样，别的文明就是你的小金库啦，诶嘿。</p>]]></content>
    
    
    <categories>
      
      <category>game</category>
      
      <category>文明6</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32入门03-KEY</title>
    <link href="/2024/05/30/stm32%E5%85%A5%E9%97%A803-KEY/"/>
    <url>/2024/05/30/stm32%E5%85%A5%E9%97%A803-KEY/</url>
    
    <content type="html"><![CDATA[<p>本实验我们所需实验的功能如下:</p><p><strong>通过开发板上的三个独立按键控制 LED 灯和蜂鸣器： KEY_UP 控制蜂鸣器翻转，KEY1 控制LED1翻转，KEY0控制LED0&#x2F;LED1同时翻转。</strong></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>而KEY的引脚图如下</p><p><img src="/.top//image-20240530200604174.png" alt="image-20240530200604174"></p><p>可以看到，当KEY未被按下时，电路处于悬空状态，即无高电平也无低电平，而当按键被按下时，根据连接电路的不同，引脚读取到的电平也不同</p><p>KEY_UP被按下时，读取的是高电平1</p><p>KEY0和KEY1被按下时，读取到的是低电平0</p><p>顺便，该开发板的KEY是独立按键，按键还应该了解矩阵键盘</p><h3 id="消抖"><a href="#消抖" class="headerlink" title="消抖"></a>消抖</h3><p>人在按下按键的过程中，会出现抖动，为了不让KEY读取每一次抖动都当作按键次数，我们需要进行消抖处理，处理方法有如下两种：</p><p><img src="/.top//image-20240530201310881.png" alt="image-20240530201310881"></p><p>老规矩，以下分为.h，.c，main三个文件分类讲解</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="h"><a href="#h" class="headerlink" title=".h"></a>.h</h3><p>1.开头自然是port,pin,时钟使能三件套</p><p>2.对设备进行操纵的函数，之前LED以及蜂鸣器都是进行写操作，而KEY则是进行读操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _KEY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _KEY_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/sys/sys.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/delay/delay.h&quot;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_GPIO_PORT          GPIOE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_GPIO_PIN           GPIO_PIN_4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_GPIO_CLK_ENABLE()  do&#123;__HAL_RCC_GPIOE_CLK_ENABLE();&#125;while(0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_GPIO_PORT          GPIOE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_GPIO_PIN           GPIO_PIN_3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_GPIO_CLK_ENABLE()  do&#123;__HAL_RCC_GPIOE_CLK_ENABLE();&#125;while(0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_GPIO_PORT          GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_GPIO_PIN           GPIO_PIN_0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_GPIO_CLK_ENABLE()  do&#123;__HAL_RCC_GPIOA_CLK_ENABLE();&#125;while(0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0  HAL_GPIO_ReadPin(KEY0_GPIO_PORT,KEY0_GPIO_PIN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1  HAL_GPIO_ReadPin(KEY1_GPIO_PORT,KEY1_GPIO_PIN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP  HAL_GPIO_ReadPin(WKUP_GPIO_PORT,WKUP_GPIO_PIN)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY0_PRES 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY1_PRES 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WKUP_PRES 3</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">KEY_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">key_scan</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> Mode)</span>;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>有意思的一点，在编写工程文件时，相较于记住底层这个命名所代表的值，不如直接使用这个命名key0_pres</p><h3 id="c"><a href="#c" class="headerlink" title=".c"></a>.c</h3><p>1.初始化IO</p><p>注：key0和key1是低电平来实现，所以设置上拉电阻，keyup是高电平实现，所以设置下拉电阻</p><p>2.key_scan函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;key.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">KEY_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>GPIO_InitTypeDef gpio_init_struct;<br>KEY0_GPIO_CLK_ENABLE();<br>KEY1_GPIO_CLK_ENABLE();<br>WKUP_GPIO_CLK_ENABLE();<br><br>gpio_init_struct.Pin=KEY0_GPIO_PIN;<br>gpio_init_struct.Pull=GPIO_PULLUP;<br>gpio_init_struct.Mode=GPIO_MODE_INPUT;<br>gpio_init_struct.Speed=GPIO_SPEED_FREQ_HIGH;<br>HAL_GPIO_Init(KEY0_GPIO_PORT,&amp;gpio_init_struct);<br><br>gpio_init_struct.Pin=KEY1_GPIO_PIN;<br>HAL_GPIO_Init(KEY1_GPIO_PORT,&amp;gpio_init_struct);<br><br>gpio_init_struct.Pin=WKUP_GPIO_PIN;<br>gpio_init_struct.Pull=GPIO_PULLDOWN;<br>HAL_GPIO_Init(WKUP_GPIO_PORT,&amp;gpio_init_struct);<br><br>&#125;<br><br><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">key_scan</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> Mode)</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> key_up = <span class="hljs-number">1</span>;<br><span class="hljs-type">uint8_t</span> key_value = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span>(Mode)  key_up = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(key_up &amp;&amp; (KEY0 == <span class="hljs-number">0</span>|| KEY1 == <span class="hljs-number">0</span> || WKUP == <span class="hljs-number">1</span>))<br>&#123;<br>delay_ms(<span class="hljs-number">10</span>);<br>key_up = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span>(KEY0 == <span class="hljs-number">0</span>) key_value = KEY0_PRES;<br><span class="hljs-keyword">if</span>(KEY1 == <span class="hljs-number">0</span>) key_value = KEY0_PRES;<br><span class="hljs-keyword">if</span>(WKUP == <span class="hljs-number">1</span>) key_value = WKUP_PRES;<br>&#125;<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(KEY0 == <span class="hljs-number">1</span> &amp;&amp; KEY1 == <span class="hljs-number">1</span> &amp;&amp; WKUP == <span class="hljs-number">0</span>)<br>&#123;<br>key_up = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> key_value;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个scan函数有意思的一点在于</p><p>static变量的使用，有兴趣的可以去查，是累加设计</p><p>然后，进而使用MODE为该按键函数的进阶做铺垫，毕竟会有根据按键次数，以及长按短按来实现不同功能的应用</p><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/sys/sys.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/delay/delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/usart/usart.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/BEEP/beep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/LED/led.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/KEY/key.h&quot;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">uint8_t</span> key;<br><br>HAL_Init();<br>sys_stm32_clock_init(RCC_PLL_MUL9);<br>delay_init(<span class="hljs-number">72</span>);<br>Beep_Init();<br>LED_INIT();<br>KEY_Init();<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>key = key_scan(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">if</span>(key) <br>&#123;<br><span class="hljs-keyword">switch</span>(key)&#123;<br><br><span class="hljs-keyword">case</span> KEY0_PRES:<br>LED0_TOGGLE();<br>  LED1_TOGGLE();<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> KEY1_PRES:<br>LED1_TOGGLE();<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> WKUP_PRES:<br>BEEP_TOGGLE();<br><span class="hljs-keyword">break</span>;<br><br>&#125;<br>&#125;<br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>老规矩，初始化铺垫，switch分支，没什么好说的</p>]]></content>
    
    
    <categories>
      
      <category>MCU</category>
      
      <category>STM32</category>
      
      <category>base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>KEY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32入门02-蜂鸣器</title>
    <link href="/2024/05/30/%E8%9C%82%E9%B8%A3%E5%99%A8/"/>
    <url>/2024/05/30/%E8%9C%82%E9%B8%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>本实验所需实现的功能如下：</p><p><strong>蜂鸣器每隔300ms响或者停一次。LED0每隔300ms亮或者灭一次。LED0亮的时候蜂鸣 器不叫，而LED0熄灭的时候，蜂鸣器叫。</strong> </p><p><img src="/.top//image-20240530111441606.png" alt="image-20240530111441606"></p><p>蜂鸣器电路图如上</p><p>可以看到，控制蜂鸣器的IO为PB8</p><p>当PB8输出高电平时，蜂鸣器发声，当PB8输出低电平时，蜂鸣器停止鸣叫</p><p><img src="/.top//image-20240530111921737.png" alt="image-20240530111921737"></p><p>接下来编写程序，和LED一样，分为.h,.c,main三个文件</p><p>顺便，其实除了IO口，以及控制设备运行的高低电平不一样，蜂鸣器和LED的运行程序大差不差</p><h3 id="h"><a href="#h" class="headerlink" title=".h"></a>.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _BEEP_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _BEEP_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/sys/sys.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEEP_GPIO_PORT              GPIOB</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEEP_GPIO_PIN               GPIO_PIN_8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEEP_GPIO_CLK_ENABLE()     do&#123;__HAL_RCC_GPIOB_CLK_ENABLE();&#125;while(0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEEP(x) do&#123;x?\</span><br><span class="hljs-meta">HAL_GPIO_WritePin(BEEP_GPIO_PORT,BEEP_GPIO_PIN,GPIO_PIN_SET):\</span><br><span class="hljs-meta">HAL_GPIO_WritePin(BEEP_GPIO_PORT,BEEP_GPIO_PIN,GPIO_PIN_RESET);\</span><br><span class="hljs-meta">                  &#125;while(0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEEP_TOGGLE() </span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Beep_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><h3 id="c"><a href="#c" class="headerlink" title=".c"></a>.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;beep.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Beep_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>GPIO_InitTypeDef gpio_init_struct;<br>BEEP_GPIO_CLK_ENABLE();<br>gpio_init_struct.Pin=BEEP_GPIO_PIN;<br>gpio_init_struct.Mode=GPIO_MODE_OUTPUT_PP;<br>gpio_init_struct.Pull=GPIO_PULLUP;<br>gpio_init_struct.Speed=GPIO_SPEED_FREQ_HIGH;<br>HAL_GPIO_Init(BEEP_GPIO_PORT,&amp;gpio_init_struct);<br><br>BEEP(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/sys/sys.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/delay/delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/usart/usart.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/BEEP/beep.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/LED/led.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>HAL_Init();<br>sys_stm32_clock_init(RCC_PLL_MUL9);<br>delay_init(<span class="hljs-number">72</span>);<br>Beep_Init();<br>LED_INIT();<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>LED0(<span class="hljs-number">0</span>);<br>BEEP(<span class="hljs-number">0</span>);<br>delay_ms(<span class="hljs-number">300</span>);<br>LED0(<span class="hljs-number">1</span>);<br>BEEP(<span class="hljs-number">1</span>);<br>delay_ms(<span class="hljs-number">300</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MCU</category>
      
      <category>STM32</category>
      
      <category>base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>蜂鸣器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32入门01-LED点亮</title>
    <link href="/2024/05/29/STM32-LED%E7%82%B9%E4%BA%AE/"/>
    <url>/2024/05/29/STM32-LED%E7%82%B9%E4%BA%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>先来介绍控制设备的基础——GPIO口</strong></p><p>[GPIO输入输出模式原理(八种工作方式附电路图详解)_gpio四种输入输出模式-CSDN博客](<a href="https://blog.csdn.net/zhuguanlin121/article/details/118489092#:~:text=1">https://blog.csdn.net/zhuguanlin121/article/details/118489092#:~:text=1</a> STM32引脚说明 2 GPIO种类 3 GPIO基本结构 4 GPIO输入输出的8种模式,6、GPIO_Mode_Out_PP：推挽输出 7、GPIO_Mode_AF_OD：复用开漏输出 8、GPIO_Mode_AF_PP：复用推挽输出 6 总结与分析 1、什么是推挽结构和推挽电路 2、开漏输出和推挽输出的区别 3、STM32如何选择I%2FO模式)</p><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><h3 id="总"><a href="#总" class="headerlink" title="总"></a>总</h3><p>GPIO简称IO口</p><p><strong>配置</strong>：7组，每组有16个IO口</p><p>七组：ABCDEFG</p><p>16个：0，1，2，3，……15</p><p>eg.PA0口</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/.top//image-20240506114518721.png" alt="image-20240506114518721"></p><p>保护二极管：阻止电流反向移动，从底边流向尖角为正向，防止过高过低的电压输入，当电压过高过低时，起分流作用，且是分99%的作用。当电压高于VDD是，电压从io到vdd导通；当电压低于vss时，电压从vss到io口导通。但是尽管如此，还是不能直接外接大功率器件，须加大功率及隔离电路驱动，防止烧坏芯片或者外接器件无法正常工作。</p><p>​VCC：C&#x3D;circuit，表示电路，即接入电路的电压</p><p>​VDD：D&#x3D;device，表示器件，即器件内部的工作电压</p><p>​VSS：S&#x3D;series，表示公共连接，即电路公共接地端电压</p><p><a href="https://zhuanlan.zhihu.com/p/551180284">科普：电路中VCC、VDD、VEE、VSS分别指什么？ - 知乎 (zhihu.com)</a></p><p>TTL肖特基触发器：信号经过触发器后，模拟信号转化为0和1的数字信号，<strong>但是，当GPIO引脚作为ADC采集电压的输入通道时，用其“模拟输入”功能，此时信号不再经过触发器进行TTL电平转换。</strong>ADC外设要采集到的原始的模拟信号。</p><p>这里需要注意的是，在查看《STM32中文参考手册V10》中的GPIO的表格时，会看到<strong>有“FT”一列，这代表着这个GPIO口时兼容3.3V和5V的；如果没有标注“FT”，就代表着不兼容5V</strong>。</p><h3 id="输出与输入"><a href="#输出与输入" class="headerlink" title="输出与输入"></a>输出与输入</h3><p><img src="/.top//image-20240506115852439.png" alt="image-20240506115852439"></p><h4 id="上拉输入"><a href="#上拉输入" class="headerlink" title="上拉输入"></a>上拉输入</h4><p><img src="/.top//image-20240506120555896.png" alt="image-20240506120555896"></p><p>上拉输入时，上拉电阻是闭合状态。</p><ol><li><p>当io口无输入信号时，上拉电阻持续输入高电平</p></li><li><p>当IO口输入低电平时，输入数据寄存器输入低电平</p></li></ol><p>因此，默认情况下输入引脚数据为1，高电平。</p><p>目的：为了使得电路更加稳定，不出现没有输入时端口的输入数据被干扰 （比如手碰一下电压就发生变化）。</p><blockquote><p>施密特触发器：施密特就是为了防止在某一个临界电平的情况出现各种情况的抖动出现，为了稳定我们的输出而设计的。<br>施密特触发器采用电位触发方式，其状态由输入信号电位维持；对于负向递减和正向递增两种不同变化方向的输入信号，施密特触发器有不同的阈值电压。</p></blockquote><h4 id="下拉输入"><a href="#下拉输入" class="headerlink" title="下拉输入"></a>下拉输入</h4><p><img src="/.top//image-20240506121156985.png" alt="image-20240506121156985"></p><p>默认情况下输入引脚为0，低电平。</p><p>下拉输入模式下，I&#x2F;O端口的电平信号直接进入输入数据寄存器。</p><p>但是在I&#x2F;O端口悬空（在无信号输入）的情况下，输入端的电平保持在低电平；</p><p>并且在I&#x2F;O端口输入为高电平的时候，输入端的电平也是高电平。</p><p>总结两种模式：上拉输入主要捕捉低电平，下拉输入捕捉高电平。</p><h4 id="浮空输入"><a href="#浮空输入" class="headerlink" title="浮空输入"></a>浮空输入</h4><p><img src="/.top//image-20240506121331214.png" alt="image-20240506121331214"></p><p>浮空输入模式下，I&#x2F;O端口的电平信号直接进入输入数据寄存器。</p><p>也就是说，I&#x2F;O的电平状态是不确定的，完全由外部输入决定；</p><p>如果在该引脚悬空（在无信号输入）的情况下，读取该端口的电平是不确定的。</p><p>通常用于IIC、USART。</p><h4 id="模拟输入"><a href="#模拟输入" class="headerlink" title="模拟输入"></a>模拟输入</h4><p><img src="/.top//image-20240506121419207.png" alt="image-20240506121419207"></p><p>模拟输入模式下，I&#x2F;O端口的模拟信号（电压信号，而非电平信号）直接模拟输入到<strong>片上外设模块</strong>，比如ADC模块等。模拟信号一般：3.3v 5v 9v。</p><p><strong>ps.电压是指确切的数值，如1.0v。而电平信号是指高电平和低电平，即0和1</strong></p><h4 id="开漏输出"><a href="#开漏输出" class="headerlink" title="开漏输出"></a>开漏输出</h4><p><img src="/.top//image-20240506121645589.png" alt="image-20240506121645589"></p><p>开漏输出模式下（N-MOS管）</p><p>输出高电平，N-MOS管处于关闭状态，IO的电平与输出毫无关系，而是由IO口决定</p><p>输出低电平，N-MOS管处于开合状态，IO口为低电平</p><p>因此，IO的电平不一定是输出的电平</p><h4 id="开漏复用输出"><a href="#开漏复用输出" class="headerlink" title="开漏复用输出"></a>开漏复用输出</h4><p><img src="/.top//image-20240506122155168.png" alt="image-20240506122155168"></p><p>开漏复用输出模式，与开漏输出模式很是类似。只是输出的高低电平的来源，不是让CPU直接写输出数据寄存器，取而代之利用片上外设模块的复用功能输出来决定的。</p><p>片内外设功能：TX1，MOSI，MISO，SCK，SS</p><h4 id="推挽输出"><a href="#推挽输出" class="headerlink" title="推挽输出"></a>推挽输出</h4><p><img src="/.top//image-20240506122323025.png" alt="image-20240506122323025"></p><p>推挽输出模式下（P-MOS管+N-MOS管）</p><p>位设置&#x2F;输出数据寄存器进行输出</p><p>输出为高电平时，P-MOS打开，IO的电平由P-MOS决定</p><p>输出为低电平时，N-MOS打开，IO的电平由N-MOS决定</p><p>因此，IO口的电平一定是输出电平</p><h4 id="推挽复用"><a href="#推挽复用" class="headerlink" title="推挽复用"></a>推挽复用</h4><p><img src="/.top//image-20240506122745209.png" alt="image-20240506122745209"></p><p>推挽复用输出模式，与推挽输出模式很是类似。只是输出的高低电平的来源，不是让CPU直接写输出数据寄存器，取而代之利用片上外设模块的复用功能输出来决定的。</p><p>片内外设功能IIC的SCL、SDL</p><h3 id="模式用途"><a href="#模式用途" class="headerlink" title="模式用途"></a>模式用途</h3><p>1、 GPIO_Mode_AIN ：模拟输入<br>一般用于ADC模拟输入</p><p>2、GPIO_Mode_IN_FLOATING ：浮空输入<br>可用于按键KEY实验、发送接收信号RX、TX、IIC、USART等，不过这些实验可以不用浮空输入，如KEY用到上拉和下拉</p><p>3、GPIO_Mode_IPD：下拉输入<br>4、GPIO_Mode_IPU：上拉输入<br>IO内部上拉电阻、下拉电组输入，使情况而定，比如刚刚说的key按键实验<br>5、GPIO_Mode_Out_OD：开漏输出<br>IO 输出 0 接 GND，IO 输出 1，悬空，需要外接上拉电阻，才能实现输出高电平。当输出为 1 时，IO 口的状态由上拉电阻拉高电平，但由于是开漏输出模式，这样 IO 口也就可以 由外部电路改变为低电平或不变。该模式适用于电平不匹配场合、适合做电流型的驱动，吸收电流能力比较强。</p><p>6、GPIO_Mode_Out_PP：推挽输出<br>可以输出高、低电平。导通损耗小、效率高。既提高电路的负载能力，又提高开关速度。广泛各种实验，比如接下来要总结的LED。</p><p>7、GPIO_Mode_AF_OD：复用开漏输出<br>当GPIO为复用IO时的开漏输出模式，一般用于外设功能，如TX1</p><p>8、GPIO_Mode_AF_PP：复用推挽输出<br>当GPIO为复用IO时的推挽输出模式，一般用于外设功能，如I2C</p><p>还有很多区别，痛苦面具</p><p>[GPIO输入输出模式原理(八种工作方式附电路图详解)_gpio四种输入输出模式-CSDN博客](<a href="https://blog.csdn.net/zhuguanlin121/article/details/118489092#:~:text=1">https://blog.csdn.net/zhuguanlin121/article/details/118489092#:~:text=1</a> STM32引脚说明 2 GPIO种类 3 GPIO基本结构 4 GPIO输入输出的8种模式,6、GPIO_Mode_Out_PP：推挽输出 7、GPIO_Mode_AF_OD：复用开漏输出 8、GPIO_Mode_AF_PP：复用推挽输出 6 总结与分析 1、什么是推挽结构和推挽电路 2、开漏输出和推挽输出的区别 3、STM32如何选择I%2FO模式)</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><img src="/.top//image-20240506123414350.png" alt="image-20240506123414350"></p><p>配置寄存器存在的原因：CRL&#x2F;CRH每四个位控制一个IO口，GPIOx_CRL共32位可控制0-7口（4<em>8），GPIOx_CRH共32位可控制8-15口（4</em>8）</p><h4 id="端口配置寄存器"><a href="#端口配置寄存器" class="headerlink" title="端口配置寄存器"></a>端口配置寄存器</h4><p>总结：</p><p>MODE0&#x3D;00时</p><p>CNF:配置输出模式</p><p>MODE配置输出速度。</p><p>MODE0大于00时</p><p>CNF:配置输入模式</p><p>MODE为0.</p><p><strong>1端口配置低寄存器</strong> <strong>(GPIOx_CRL) (x&#x3D;A..E)</strong></p><p><img src="/.top//image-20240506123843687.png" alt="image-20240506123843687"></p><p><strong>2端口配置高寄存器</strong> <strong>(GPIOx_CRH) (x&#x3D;A..E)</strong></p><p><img src="/.top//image-20240506123927546.png" alt="image-20240506123927546"></p><h4 id="输出输入"><a href="#输出输入" class="headerlink" title="输出输入"></a>输出输入</h4><p><img src="/.top//image-20240506124121450.png" alt="image-20240506124121450"></p><h4 id="端口位设置"><a href="#端口位设置" class="headerlink" title="端口位设置"></a>端口位设置</h4><p><img src="/.top//image-20240506124426911.png" alt="3"></p><p><img src="/.top//image-20240529093018891.png" alt="image-20240529093018891"></p><h4 id="锁定端口"><a href="#锁定端口" class="headerlink" title="锁定端口"></a>锁定端口</h4><p><img src="/.top//image-20240506124658683.png" alt="image-20240506124658683"></p><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>时钟相当于使用一个设置的开关。</p><p>51只有一个时钟，所以即使只启用了一个设置，其它设置也会进行相应的配置，相当于牵一发而动全身，因此，及其损耗资源</p><p>32至少有四个以上的时钟，从而做到了精密和精细，将资源尽量利用不浪费</p><p><img src="/.top//image-20240529124314904.png" alt="image-20240529124314904"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>以下只是使用LED时，启用时钟的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED0_GPIO_CLK_ENABLE()          do&#123; __HAL_RCC_GPIOB_CLK_ENABLE(); &#125;while(0)    </span><br></code></pre></td></tr></table></figure><p>用do while循环能够确保LED的时钟使能像函数一样被调用</p><p>当一个设置的时钟使能要经历多层CLK调用时，do while循环则可以一次性做到这点，让使能函数简洁。</p><h2 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h2><p><img src="/.top//image-20240506205006770.png" alt="image-20240506205006770"></p><p>以上为LED的引脚图，接下来我们以此为根据，配置代码</p><p>据说为了可移植性，.h和.c的各司其职</p><h3 id="h"><a href="#h" class="headerlink" title=".h"></a>.h</h3><ol><li>先定义引脚口</li><li>再定义时钟使能</li><li>定义运作函数，比如LED就需要输入0，才能点亮</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _LED_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _LED_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/sys/sys.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED0_GPIO_PORT           GPIOB</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED0_GPIO_PIN            GPIO_PIN_5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED0_GPIO_CLK_ENABLE()   do&#123;__HAL_RCC_GPIOB_CLK_ENABLE(); &#125;while(0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_GPIO_PORT           GPIOE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_GPIO_PIN            GPIO_PIN_5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_GPIO_CLK_ENABLE()   do&#123;__HAL_RCC_GPIOE_CLK_ENABLE(); &#125;while(0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED0(x)   do&#123; x ? \</span><br><span class="hljs-meta">HAL_GPIO_WritePin(LED0_GPIO_PORT,LED0_GPIO_PIN,GPIO_PIN_SET):\</span><br><span class="hljs-meta">HAL_GPIO_WritePin(LED0_GPIO_PORT,LED0_GPIO_PIN,GPIO_PIN_RESET);\</span><br><span class="hljs-meta">                  &#125;while(0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1(x)   do&#123; x ? \</span><br><span class="hljs-meta">HAL_GPIO_WritePin(LED1_GPIO_PORT,LED1_GPIO_PIN,GPIO_PIN_SET):\</span><br><span class="hljs-meta">HAL_GPIO_WritePin(LED1_GPIO_PORT,LED1_GPIO_PIN,GPIO_PIN_RESET);\</span><br><span class="hljs-meta">&#125;while(0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED0_TOGGLE()   do&#123; HAL_GPIO_TogglePin(LED0_GPIO_PORT, LED0_GPIO_PIN); &#125;while(0)       </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_TOGGLE()   do&#123; HAL_GPIO_TogglePin(LED1_GPIO_PORT, LED1_GPIO_PIN); &#125;while(0)        </span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED_INIT</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br><br></code></pre></td></tr></table></figure><h3 id="c"><a href="#c" class="headerlink" title=".c"></a>.c</h3><ol><li>时钟使能</li><li>GPIO口初始化</li><li>关掉设备</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/LED/LED.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED_INIT</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>GPIO_InitTypeDef gpio_init_struct;<br>LED0_GPIO_CLK_ENABLE();<br>LED1_GPIO_CLK_ENABLE();<br><br>gpio_init_struct.Pin = LED0_GPIO_PIN;<br>gpio_init_struct.Mode = GPIO_MODE_OUTPUT_PP;<br>gpio_init_struct.Pull = GPIO_PULLUP;<br>gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;<br>HAL_GPIO_Init(LED0_GPIO_PORT,&amp;gpio_init_struct);<br><br>gpio_init_struct.Pin = LED1_GPIO_PIN;<br>HAL_GPIO_Init(LED1_GPIO_PORT,&amp;gpio_init_struct);<br><br>LED0(<span class="hljs-number">1</span>);<br>LED1(<span class="hljs-number">1</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><ol><li><p>初始化HAL库</p></li><li><p>初始化时钟</p></li><li><p>延时，为初始化留下时间</p></li><li><p>初始化LED</p></li><li><p>do while循环</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/sys/sys.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/delay/delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./SYSTEM/usart/usart.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/LED/led.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>HAL_Init();<br>sys_stm32_clock_init(RCC_PLL_MUL9);<br>delay_init(<span class="hljs-number">72</span>);<br>LED_INIT();<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>LED0(<span class="hljs-number">0</span>);                                <span class="hljs-comment">/* LED0 ?? */</span><br>LED1(<span class="hljs-number">1</span>);                                <span class="hljs-comment">/* LED1 ?? */</span><br>delay_ms(<span class="hljs-number">500</span>);<br>LED0(<span class="hljs-number">1</span>);                                <span class="hljs-comment">/* LED0 ?? */</span><br>LED1(<span class="hljs-number">0</span>);                                <span class="hljs-comment">/* LED1 ?? */</span><br>delay_ms(<span class="hljs-number">500</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注:LED的开关，也可以通过LED0_TOGGLE()的电平翻转改变</p><p>ps.电阻上拉下拉都不会有影响</p><p><img src="/.top//image-20240529151225362.png" alt="image-20240529151225362"></p><p>结果如下</p><p><img src="/.top//aa5c24efd411766bae2ec31255212dda_720.jpg" alt="aa5c24efd411766bae2ec31255212dda_720"></p><p><img src="/.top//90307b1eb396faf0e258daef1690ef9d_720-1716971404072-22.jpg" alt="90307b1eb396faf0e258daef1690ef9d_720"></p>]]></content>
    
    
    <categories>
      
      <category>MCU</category>
      
      <category>STM32</category>
      
      <category>base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>LED</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文明6-如何增加科技值</title>
    <link href="/2024/05/28/%E6%96%87%E6%98%8E6-%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E7%A7%91%E6%8A%80%E5%80%BC/"/>
    <url>/2024/05/28/%E6%96%87%E6%98%8E6-%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E7%A7%91%E6%8A%80%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="如何增加科技值"><a href="#如何增加科技值" class="headerlink" title="如何增加科技值"></a>如何增加科技值</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Q:为什么增加科技值？</p><p>A:加快科技树的点亮速度，在与其它文明争霸时，获得领先地位</p><p>ps.当自家文明还用弓箭手的时候，蛮族都用上线列步兵的窒息感，让人很想吐槽到底谁才是蛮族</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="一、单元格"><a href="#一、单元格" class="headerlink" title="一、单元格"></a>一、单元格</h3><p>有些单元格是可以直接获取科技值的，只需将该单元格的市民图标点亮，则可获得相应的科技值</p><p>而在奇观如百慕大三角附近，所获得的科技值灰常多（听说的，还没遇到过百慕大三角）</p><h3 id="二、学院"><a href="#二、学院" class="headerlink" title="二、学院"></a>二、学院</h3><p>并不是建成学院就可以获得科技值，如果其周围没有任何加成的话，科技值收入为0，相当于浪费生产力。</p><p>而加成分为三部分</p><p>1.地形，相应的地形让学院获得加成，从而增加科技值</p><p>2.建筑</p><p>3.市民，当学院升级为图书馆的时候，就可以点亮上面的市民图标，每个市民点亮2点科技值（是点亮在图书馆的市民），后期到大学的时候，可以点亮三个市民</p><p>ps.市民点亮并非越多越好，不然粮食生产以及其它方面会落下。</p><h3 id="三、掠夺"><a href="#三、掠夺" class="headerlink" title="三、掠夺"></a>三、掠夺</h3><p>是你！野蛮6（doge）</p><p>当你掠夺其他文明的学院时，就可以获得他们学院的科技值，这等好事！！！</p><p>挂路灯典中做法：不管周围文明，但要确保自身兵力强盛，等肥羊可宰之时，一举进攻，掠夺开抢，之后潇洒离去，让羊继续养肥</p>]]></content>
    
    
    <categories>
      
      <category>game</category>
      
      <category>文明6</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
